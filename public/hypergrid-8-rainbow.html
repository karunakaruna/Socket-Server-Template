<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>HyperGrid 8 - Rainbow Lines</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
    <style>
        body { margin: 0; background: #000; overflow: hidden; }
        canvas { width: 100vw; height: 100vh; }
        #hud {
            position: fixed;
            top: 20px;
            right: 20px;
            color: #0ff;
            font-family: monospace;
            background: rgba(0,0,32,0.8);
            padding: 20px;
            border: 1px solid #0ff;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    <div id="hud">
        <div>W: <span id="w">0.000</span></div>
        <div>X: <span id="x">0.000</span></div>
        <div>Y: <span id="y">0.000</span></div>
        <div>Z: <span id="z">0.000</span></div>
    </div>
    <script>
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl', { alpha: false, antialias: true });
        
        const vsSource = `
            attribute vec4 position;
            attribute vec4 color;
            uniform mat4 matrix;
            varying vec4 vColor;
            void main() {
                gl_Position = matrix * position;
                vColor = color;
                gl_PointSize = 3.0;
            }
        `;

        const fsSource = `
            precision highp float;
            varying vec4 vColor;
            void main() {
                gl_FragColor = vec4(vColor.rgb * 1.5, vColor.a); // Make colors brighter
            }
        `;

        // Create shader program
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            return shader;
        }

        const program = gl.createProgram();
        gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, vsSource));
        gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, fsSource));
        gl.linkProgram(program);
        gl.useProgram(program);

        const positionLocation = gl.getAttribLocation(program, 'position');
        const colorLocation = gl.getAttribLocation(program, 'color');
        const matrixLocation = gl.getUniformLocation(program, 'matrix');

        function createRainbowLines() {
            const vertices = [];
            const colors = [];
            const numLines = 200; // More lines!
            
            function addLine(x1, y1, z1, w1, x2, y2, z2, w2, r, g, b) {
                vertices.push(x1, y1, z1, w1, x2, y2, z2, w2);
                colors.push(r, g, b, 1, r, g, b, 1);
            }

            // Create a rainbow spectrum
            for(let i = 0; i < numLines; i++) {
                const t = i / numLines;
                const angle = t * Math.PI * 2;
                const radius = 2.0;
                
                // Rainbow color calculation
                const r = Math.sin(t * Math.PI * 2) * 0.5 + 0.5;
                const g = Math.sin(t * Math.PI * 2 + Math.PI * 2/3) * 0.5 + 0.5;
                const b = Math.sin(t * Math.PI * 2 + Math.PI * 4/3) * 0.5 + 0.5;

                // Create lines in different planes
                // WX plane
                addLine(
                    Math.cos(angle) * radius, Math.sin(angle) * radius, 0, 0,
                    Math.cos(angle + 0.1) * radius, Math.sin(angle + 0.1) * radius, 0, 0,
                    r, g, b
                );

                // WY plane
                addLine(
                    Math.cos(angle) * radius, 0, Math.sin(angle) * radius, 0,
                    Math.cos(angle + 0.1) * radius, 0, Math.sin(angle + 0.1) * radius, 0,
                    b, r, g
                );

                // WZ plane
                addLine(
                    Math.cos(angle) * radius, 0, 0, Math.sin(angle) * radius,
                    Math.cos(angle + 0.1) * radius, 0, 0, Math.sin(angle + 0.1) * radius,
                    g, b, r
                );

                // Add crossing lines
                addLine(
                    Math.cos(angle), Math.sin(angle), Math.cos(angle), Math.sin(angle),
                    Math.cos(angle + 0.1), Math.sin(angle + 0.1), Math.cos(angle + 0.1), Math.sin(angle + 0.1),
                    r, g, b
                );
            }

            // Add extra bright central axes
            addLine(-2, 0, 0, 0, 2, 0, 0, 0, 1, 1, 1); // W axis (white)
            addLine(0, -2, 0, 0, 0, 2, 0, 0, 1, 0.3, 0.3); // X axis (red)
            addLine(0, 0, -2, 0, 0, 0, 2, 0, 0.3, 1, 0.3); // Y axis (green)
            addLine(0, 0, 0, -2, 0, 0, 0, 2, 0.3, 0.3, 1); // Z axis (blue)

            return { vertices, colors };
        }

        const { vertices, colors } = createRainbowLines();
        
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

        const colorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);

        let rotation = { x: 0, y: 0, z: 0, w: 0 };
        
        function updateRotation() {
            const time = Date.now() * 0.001;
            rotation.x = Math.sin(time * 0.3) * 0.5;
            rotation.y = Math.cos(time * 0.4) * 0.5;
            rotation.z = Math.sin(time * 0.5) * 0.5;
            rotation.w = Math.cos(time * 0.6) * 0.5;
            
            document.getElementById('w').textContent = rotation.w.toFixed(3);
            document.getElementById('x').textContent = rotation.x.toFixed(3);
            document.getElementById('y').textContent = rotation.y.toFixed(3);
            document.getElementById('z').textContent = rotation.z.toFixed(3);
        }

        function getRotationMatrix() {
            const matrix = mat4.create();
            mat4.rotateX(matrix, matrix, rotation.x);
            mat4.rotateY(matrix, matrix, rotation.y);
            mat4.rotateZ(matrix, matrix, rotation.z);
            mat4.perspective(matrix, Math.PI/3, canvas.width/canvas.height, 0.1, 100.0);
            mat4.translate(matrix, matrix, [0, 0, -5]);
            return matrix;
        }

        function render() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);

            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
            gl.lineWidth(2.0);

            updateRotation();
            gl.uniformMatrix4fv(matrixLocation, false, getRotationMatrix());

            gl.enableVertexAttribArray(positionLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(positionLocation, 4, gl.FLOAT, false, 0, 0);

            gl.enableVertexAttribArray(colorLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.vertexAttribPointer(colorLocation, 4, gl.FLOAT, false, 0, 0);

            gl.drawArrays(gl.LINES, 0, vertices.length / 4);

            requestAnimationFrame(render);
        }

        render();

        // Interactive rotation
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        canvas.addEventListener('mousedown', e => {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        canvas.addEventListener('mousemove', e => {
            if (!isDragging) return;
            const deltaX = e.clientX - lastMouseX;
            const deltaY = e.clientY - lastMouseY;
            rotation.x += deltaY * 0.01;
            rotation.y += deltaX * 0.01;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        canvas.addEventListener('mouseup', () => isDragging = false);
        canvas.addEventListener('mouseleave', () => isDragging = false);

        // Add touch support
        canvas.addEventListener('touchstart', e => {
            isDragging = true;
            lastMouseX = e.touches[0].clientX;
            lastMouseY = e.touches[0].clientY;
        });

        canvas.addEventListener('touchmove', e => {
            if (!isDragging) return;
            const deltaX = e.touches[0].clientX - lastMouseX;
            const deltaY = e.touches[0].clientY - lastMouseY;
            rotation.x += deltaY * 0.01;
            rotation.y += deltaX * 0.01;
            lastMouseX = e.touches[0].clientX;
            lastMouseY = e.touches[0].clientY;
        });

        canvas.addEventListener('touchend', () => isDragging = false);
    </script>
</body>
</html>
