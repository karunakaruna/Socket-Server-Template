<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HyperGrid Core</title>
    <style>
        /* Original styles */
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100vw;
            height: 100vh;
        }
        
        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }
        
        #quantum-navigator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 200px;
            border: 2px solid rgba(0, 255, 255, 0.2);
            border-radius: 50%;
            cursor: crosshair;
            background: radial-gradient(circle at 50% 50%,
                rgba(255, 255, 255, 0.1),
                rgba(0, 100, 255, 0.15),
                rgba(0, 0, 0, 0.5)
            );
            box-shadow: 0 0 40px rgba(0, 100, 255, 0.2);
            z-index: 1000;
            touch-action: none;
            pointer-events: auto;
        }

        #navigator-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            pointer-events: none;
        }

        #navigator-grid::before,
        #navigator-grid::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.1);
        }

        #navigator-grid::before {
            top: 50%;
            left: 0;
            width: 100%;
            height: 1px;
            transform: translateY(-50%);
        }

        #navigator-grid::after {
            top: 0;
            left: 50%;
            width: 1px;
            height: 100%;
            transform: translateX(-50%);
        }

        #navigator-vector {
            position: absolute;
            width: 6px;
            height: 6px;
            background: rgba(0, 255, 255, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px cyan;
        }

        #quantum-hud {
            position: fixed;
            top: 20px;
            left: 20px;
            font-family: 'Courier New', monospace;
            color: rgba(0, 255, 255, 0.8);
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            pointer-events: none;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(0, 255, 255, 0.2);
            backdrop-filter: blur(5px);
        }

        .quantum-coordinate {
            margin: 5px 0;
            display: flex;
            align-items: center;
        }

        .coordinate-label {
            width: 120px;
            opacity: 0.7;
        }

        .coordinate-value {
            font-family: 'Consolas', monospace;
            color: #0ff;
        }

        .manifold-info {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid rgba(0, 255, 255, 0.2);
        }

        .quantum-bar {
            width: 100px;
            height: 4px;
            background: rgba(0, 255, 255, 0.2);
            margin-left: 10px;
            border-radius: 2px;
            overflow: hidden;
        }

        .quantum-bar-fill {
            height: 100%;
            background: rgba(0, 255, 255, 0.8);
            transition: width 0.3s ease;
        }

        /* New Core Proximity Effect */
        .core-proximity {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100px;
            height: 100px;
            background: radial-gradient(circle at center,
                rgba(255, 0, 255, 0.2) 0%,
                rgba(0, 255, 255, 0.1) 50%,
                transparent 100%
            );
            border-radius: 50%;
            pointer-events: none;
            z-index: 999;
            opacity: 0;
            transition: all 0.3s ease;
        }

        .core-proximity.active {
            opacity: 1;
            width: 200px;
            height: 200px;
        }

        .core-indicator {
            position: fixed;
            top: 10px;
            right: 10px;
            font-family: 'Courier New', monospace;
            color: #ff00ff;
            text-shadow: 0 0 10px rgba(255, 0, 255, 0.5);
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
            border: 1px solid rgba(255, 0, 255, 0.3);
            display: none;
        }

        .core-indicator.visible {
            display: block;
        }

        /* Control panel styles */
        .control-panel {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            z-index: 1000;
        }

        .control-btn {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid rgba(0, 255, 255, 0.3);
            color: #0ff;
            padding: 8px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            transition: all 0.3s ease;
            min-width: 80px;
            text-align: center;
        }

        .control-btn:hover {
            background: rgba(0, 255, 255, 0.2);
            border-color: rgba(0, 255, 255, 0.5);
        }

        .control-btn.active {
            background: rgba(0, 255, 255, 0.3);
            border-color: rgba(0, 255, 255, 0.8);
        }

        /* Manifold visualization */
        .manifold-vis {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 300px;
            height: 200px;
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 15px;
            padding: 15px;
            backdrop-filter: blur(10px);
            display: none;
            z-index: 1000;
            transition: all 0.3s ease;
        }

        .manifold-stats {
            position: absolute;
            bottom: 10px;
            left: 15px;
            right: 15px;
            color: #0ff;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            display: flex;
            justify-content: space-between;
            opacity: 0.8;
        }

        .manifold-stats span {
            color: #f0f;
        }

        .manifold-axis-label {
            position: absolute;
            color: rgba(0, 255, 255, 0.6);
            font-family: 'Courier New', monospace;
            font-size: 10px;
        }

        .manifold-axis-label.x {
            bottom: 25px;
            left: 50%;
            transform: translateX(-50%);
        }

        .manifold-axis-label.y {
            top: 50%;
            left: 5px;
            transform: rotate(-90deg) translateX(-50%);
            transform-origin: left center;
        }

        .manifold-vis.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .manifold-canvas {
            width: 100%;
            height: 100%;
            border-radius: 10px;
        }

        .manifold-label {
            position: absolute;
            top: -20px;
            left: 15px;
            color: #0ff;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            opacity: 0.8;
        }

        /* Core visualization styles */
        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }
        
        .stats {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #0ff;
            font-family: 'Courier New', monospace;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 10px;
            z-index: 1;
        }

        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 1;
        }

        button {
            background: rgba(0, 0, 0, 0.7);
            color: #0ff;
            border: 1px solid rgba(0, 255, 255, 0.3);
            padding: 8px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            transition: all 0.3s ease;
        }

        button:hover {
            background: rgba(0, 255, 255, 0.1);
        }

        button.active {
            background: rgba(0, 255, 255, 0.2);
        }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    <div id="quantum-navigator">
        <div id="navigator-grid"></div>
        <div id="navigator-vector"></div>
    </div>
    <div id="quantum-hud">
        <div class="quantum-coordinate">
            <span class="coordinate-label">Phase:</span>
            <span class="coordinate-value">0.00Ï€</span>
        </div>
        <div class="quantum-coordinate">
            <span class="coordinate-label">Spin:</span>
            <span class="coordinate-value">â†‘</span>
        </div>
        <div class="quantum-coordinate">
            <span class="coordinate-label">Entangled:</span>
            <span class="coordinate-value">No</span>
        </div>
        <div class="manifold-info">
            <div class="quantum-coordinate">
                <span class="coordinate-label">Manifold Depth:</span>
                <span class="coordinate-value">Î»=0.800</span>
            </div>
            <div class="quantum-coordinate">
                <span class="coordinate-label">Curvature:</span>
                <span class="coordinate-value">Îº=1.400</span>
            </div>
            <div class="quantum-coordinate">
                <span class="coordinate-label">Q-Entropy:</span>
                <span class="coordinate-value">1.317 qbits</span>
            </div>
        </div>
    </div>
    <div class="core-proximity"></div>
    <div class="core-indicator">CORE PROXIMITY ALERT v2.1</div>

    <!-- Control Panel -->
    <div class="control-panel">
        <div class="control-btn" id="homeBtn">HOME</div>
        <div class="control-btn" id="stopBtn">STOP</div>
        <div class="control-btn" id="manifoldBtn">MANIFOLD</div>
    </div>

    <!-- Manifold Visualization -->
    <div class="manifold-vis">
        <div class="manifold-label">MANIFOLD TOPOLOGY</div>
        <canvas id="manifoldCanvas" class="manifold-canvas"></canvas>
        <div class="manifold-axis-label x">SPATIAL POSITION</div>
        <div class="manifold-axis-label y">CURVATURE</div>
        <div class="manifold-stats">
            <div>Î»=<span id="manifoldDepth">0.000</span></div>
            <div>Îº=<span id="manifoldCurv">0.000</span></div>
            <div>âˆ‡=<span id="manifoldGrad">0.000</span></div>
        </div>
    </div>

    <script>
        // Global variables
        let coreCanvas, trailCanvas, coreCtx, trailCtx;
        let mouseX = 0, mouseY = 0;
        let mousePressed = false;
        let keyState = new Set();
        let diveDepth = 0;
        let dimensionalPhase = 0;
        let playerEnergy = 0;
        let psiBoids = [];
        let dimensionalEchoes = [];
        let discoveredPatterns = new Set();
        let quantumStructures = [];

        // Initialize visualization parameters
        const visualParams = {
            traceDepth: 0.5,
            stringResonance: 0.7,
            patternDensity: 0.6,
            echoPersistence: 0.8
        };

        // PsiBoid class definition
        class PsiBoid {
            constructor(x, y, energy) {
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.energy = energy;
                // Assign type with specific behaviors and colors
                this.type = ['CoreDancer', 'PathFinder', 'EnergyWeaver', 'QuantumGuide'][Math.floor(Math.random() * 4)];
                switch(this.type) {
                    case 'CoreDancer':
                        this.color = 'rgba(255, 0, 255, 0.8)'; // Purple
                        this.coreAttraction = 0.5;
                        this.separationForce = 2.0;
                        break;
                    case 'PathFinder':
                        this.color = 'rgba(0, 255, 255, 0.8)'; // Cyan
                        this.coreAttraction = 0.2;
                        this.explorationRange = 300;
                        break;
                    case 'EnergyWeaver':
                        this.color = 'rgba(255, 255, 0, 0.8)'; // Yellow
                        this.networkRange = 100;
                        this.energyTransferRate = 0.1;
                        break;
                    case 'QuantumGuide':
                        this.color = 'rgba(0, 255, 0, 0.8)'; // Green
                        this.playerAttraction = 0.3;
                        this.guidanceRange = 200;
                        break;
                }
            }

            update(boids, time) {
                const centerX = coreCanvas.width/2;
                const centerY = coreCanvas.height/2;
                const dx = centerX - this.x;
                const dy = centerY - this.y;
                const distToCenter = Math.sqrt(dx * dx + dy * dy);
                
                // Base movement speed reduced
                const maxSpeed = 2;
                
                switch(this.type) {
                    case 'CoreDancer':
                        // Orbital pattern around core
                        const angle = Math.atan2(dy, dx);
                        this.vx += Math.cos(angle) * this.coreAttraction - Math.sin(angle) * 0.5;
                        this.vy += Math.sin(angle) * this.coreAttraction + Math.cos(angle) * 0.5;
                        
                        // Separation from other dancers
                        boids.forEach(other => {
                            if (other !== this && other.type === 'CoreDancer') {
                                const sepDx = this.x - other.x;
                                const sepDy = this.y - other.y;
                                const dist = Math.sqrt(sepDx * sepDx + sepDy * sepDy);
                                if (dist < 50) {
                                    this.vx += (sepDx / dist) * this.separationForce;
                                    this.vy += (sepDy / dist) * this.separationForce;
                                }
                            }
                        });
                        break;
                        
                    case 'PathFinder':
                        // Arc pattern exploration
                        const exploreDist = Math.sin(time + this.x * 0.01) * this.explorationRange;
                        const exploreAngle = time * 0.2 + this.y * 0.01;
                        this.vx += (centerX + Math.cos(exploreAngle) * exploreDist - this.x) * 0.01;
                        this.vy += (centerY + Math.sin(exploreAngle) * exploreDist - this.y) * 0.01;
                        break;
                        
                    case 'EnergyWeaver':
                        // Network formation with energy transfer
                        let nearbyCount = 0;
                        boids.forEach(other => {
                            if (other !== this) {
                                const netDx = other.x - this.x;
                                const netDy = other.y - this.y;
                                const dist = Math.sqrt(netDx * netDx + netDy * netDy);
                                if (dist < this.networkRange) {
                                    nearbyCount++;
                                    if (this.energy > other.energy) {
                                        other.energy += this.energyTransferRate;
                                        this.energy -= this.energyTransferRate;
                                    }
                                }
                            }
                        });
                        // Move towards areas with more boids if energized
                        if (this.energy > 0.5) this.networkRange = 150;
                        else this.networkRange = 100;
                        break;
                        
                    case 'QuantumGuide':
                        // Guide behavior towards player and interesting areas
                        const playerDx = mouseX - this.x;
                        const playerDy = mouseY - this.y;
                        const playerDist = Math.sqrt(playerDx * playerDx + playerDy * playerDy);
                        if (playerDist < this.guidanceRange) {
                            this.vx += playerDx * this.playerAttraction * 0.01;
                            this.vy += playerDy * this.playerAttraction * 0.01;
                        }
                        // Also slightly attracted to high-energy areas
                        boids.forEach(other => {
                            if (other !== this && other.energy > 0.7) {
                                const guideDx = other.x - this.x;
                                const guideDy = other.y - this.y;
                                const dist = Math.sqrt(guideDx * guideDx + guideDy * guideDy);
                                if (dist < this.guidanceRange) {
                                    this.vx += guideDx * 0.001;
                                    this.vy += guideDy * 0.001;
                                }
                            }
                        });
                        break;
                }

                // Apply velocity limits
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (speed > maxSpeed) {
                    this.vx = (this.vx / speed) * maxSpeed;
                    this.vy = (this.vy / speed) * maxSpeed;
                }

                // Update position
                this.x += this.vx;
                this.y += this.vy;

                // Boundary wrapping with smooth transition
                const margin = 50;
                if (this.x < -margin) this.x = coreCanvas.width + margin;
                if (this.x > coreCanvas.width + margin) this.x = -margin;
                if (this.y < -margin) this.y = coreCanvas.height + margin;
                if (this.y > coreCanvas.height + margin) this.y = -margin;
            }

            draw(ctx) {
                // Ensure size is always positive
                const size = Math.max(2, 3 + this.energy * 2);
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw energy connections for EnergyWeavers with positive radius
                if (this.type === 'EnergyWeaver' && this.energy > 0.5) {
                    ctx.strokeStyle = 'rgba(255, 255, 0, 0.2)';
                    ctx.lineWidth = Math.max(0.5, this.energy);
                    psiBoids.forEach(other => {
                        if (other !== this && other.type === 'EnergyWeaver') {
                            const dx = other.x - this.x;
                            const dy = other.y - this.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < this.networkRange && dist > 0) {  // Ensure positive distance
                                ctx.beginPath();
                                ctx.moveTo(this.x, this.y);
                                ctx.lineTo(other.x, other.y);
                                ctx.stroke();
                            }
                        }
                    });
                }

                // Add subtle glow effect for all entities
                const glowSize = size * 2;
                const glow = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, glowSize
                );
                glow.addColorStop(0, this.color.replace('0.8', '0.3'));
                glow.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = glow;
                ctx.beginPath();
                ctx.arc(this.x, this.y, glowSize, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // DimensionalEcho class definition
        class DimensionalEcho {
            constructor(x, y, pattern) {
                this.x = x;
                this.y = y;
                this.pattern = pattern;
                this.strength = 1.0;
                this.phase = Math.random() * Math.PI * 2;
                this.frequency = 1 + Math.random() * 2;
                this.dimension = Math.random() * 4;
            }
            
            draw(ctx, time) {
                const alpha = this.strength * 0.3 * visualParams.echoPersistence;
                const size = 30 + Math.sin(time * this.frequency + this.phase) * 10;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(time * 0.5);
                
                ctx.strokeStyle = `hsla(${180 + this.dimension * 30}, 100%, 70%, ${alpha})`;
                ctx.lineWidth = 1;
                
                switch(this.pattern) {
                    case 'vortex':
                        // Draw tetrahedron
                        const h = size * Math.sqrt(6) / 3;
                        ctx.beginPath();
                        for(let i = 0; i < 5; i++) {
                            const angle = (i / 5) * Math.PI * 2 + time;
                            const radius = size * (1 + Math.sin(angle + time));
                            ctx.beginPath();
                            ctx.arc(0, 0, radius, 0, Math.PI * 0.5);
                            ctx.stroke();
                        }
                        ctx.closePath();
                        ctx.moveTo(0, -h);
                        for(let i = 0; i < 3; i++) {
                            const angle = (i / 3) * Math.PI * 2;
                            const px = Math.cos(angle) * size;
                            const py = Math.sin(angle) * size;
                            ctx.lineTo(px, py);
                            ctx.moveTo(0, -h);
                        }
                        ctx.stroke();
                        break;
                        
                    case 'lattice':
                        // Draw cube
                        for(let i = -2; i <= 2; i++) {
                            for(let j = -2; j <= 2; j++) {
                                ctx.beginPath();
                                ctx.arc(i * size/2, j * size/2, 2, 0, Math.PI * 2);
                                ctx.stroke();
                            }
                        }
                        break;
                        
                    case 'wave':
                        ctx.beginPath();
                        for(let i = -size; i <= size; i += 5) {
                            const y = Math.sin(i * 0.1 + time) * 10;
                            ctx.lineTo(i, y);
                        }
                        ctx.stroke();
                        break;
                }
                
                ctx.restore();
                
                this.strength *= 0.99;
            }
        }

        // Event listeners
        window.addEventListener('resize', initCanvas);
        window.addEventListener('keydown', e => keyState.add(e.key.toLowerCase()));
        window.addEventListener('keyup', e => keyState.delete(e.key.toLowerCase()));
        
        function initCanvas() {
            coreCanvas = document.getElementById('glCanvas');
            trailCanvas = document.createElement('canvas');
            trailCanvas.style.position = 'absolute';
            trailCanvas.style.top = '0';
            trailCanvas.style.left = '0';
            trailCanvas.style.width = '100%';
            trailCanvas.style.height = '100%';
            trailCanvas.style.zIndex = '999';
            document.body.appendChild(trailCanvas);
            coreCtx = coreCanvas.getContext('2d');
            trailCtx = trailCanvas.getContext('2d');

            coreCanvas.width = window.innerWidth;
            coreCanvas.height = window.innerHeight;
            trailCanvas.width = window.innerWidth;
            trailCanvas.height = window.innerHeight;

            // Add canvas event listeners
            coreCanvas.addEventListener('mousemove', e => {
                const rect = coreCanvas.getBoundingClientRect();
                mouseX = e.clientX - rect.left;
                mouseY = e.clientY - rect.top;
            });
            coreCanvas.addEventListener('mousedown', () => mousePressed = true);
            coreCanvas.addEventListener('mouseup', () => mousePressed = false);

            // Initialize psi-boids
            psiBoids = [];
            for (let i = 0; i < 500; i++) {
                psiBoids.push(new PsiBoid(
                    Math.random() * coreCanvas.width,
                    Math.random() * coreCanvas.height,
                    (Math.random() - 0.5) * 200
                ));
            }

            // Initialize quantum structures
            initQuantumStructures();

            // Add visualization controls
            const controls = document.createElement('div');
            controls.style.position = 'fixed';
            controls.style.right = '20px';
            controls.style.top = '20px';
            controls.style.background = 'rgba(0, 20, 20, 0.8)';
            controls.style.padding = '15px';
            controls.style.borderRadius = '10px';
            controls.style.color = '#0ff';
            controls.style.fontFamily = 'monospace';
            controls.style.zIndex = '2000';
            controls.innerHTML = `
                <div style="margin-bottom: 10px">Quantum Vision Controls</div>
                <div style="margin-bottom: 8px">
                    <label>Trace Depth</label><br>
                    <input type="range" id="traceDepth" min="0" max="100" value="${visualParams.traceDepth * 100}">
                </div>
                <div style="margin-bottom: 8px">
                    <label>String Resonance</label><br>
                    <input type="range" id="stringResonance" min="0" max="100" value="${visualParams.stringResonance * 100}">
                </div>
                <div style="margin-bottom: 8px">
                    <label>Pattern Density</label><br>
                    <input type="range" id="patternDensity" min="0" max="100" value="${visualParams.patternDensity * 100}">
                </div>
                <div>
                    <label>Echo Persistence</label><br>
                    <input type="range" id="echoPersistence" min="0" max="100" value="${visualParams.echoPersistence * 100}">
                </div>
            `;
            document.body.appendChild(controls);

            // Update parameters from sliders
            ['traceDepth', 'stringResonance', 'patternDensity', 'echoPersistence'].forEach(param => {
                const slider = document.getElementById(param);
                slider.addEventListener('input', (e) => {
                    visualParams[param] = e.target.value / 100;
                });
            });
        }

        // Initialize quantum structures at different depths
        function initQuantumStructures() {
            quantumStructures = [];
            const DEPTH_LAYERS = 5;
            const STRUCTURES_PER_LAYER = 3;
            
            for (let depth = 0; depth < DEPTH_LAYERS; depth++) {
                const layer = [];
                for (let i = 0; i < STRUCTURES_PER_LAYER; i++) {
                    const centerX = coreCanvas.width/2;
                    const centerY = coreCanvas.height/2;
                    const angle = (i / STRUCTURES_PER_LAYER) * Math.PI * 2;
                    const radius = 150 + depth * 100;
                    
                    layer.push({
                        type: ['tetrahedron', 'cube', 'octahedron', 'dodecahedron'][Math.floor(Math.random() * 4)],
                        x: centerX + Math.cos(angle) * radius,
                        y: centerY + Math.sin(angle) * radius,
                        size: 30 + Math.random() * 20,
                        rotation: Math.random() * Math.PI * 2,
                        phase: Math.random() * Math.PI * 2,
                        frequency: 1 + Math.random() * 2,
                        dimension: Math.random() * 4
                    });
                }
                quantumStructures.push(layer);
            }
        }

        // Draw platonic solids
        function drawPlatonicSolid(ctx, type, x, y, size, rotation, alpha) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation);
            
            ctx.strokeStyle = `hsla(${180 + alpha * 30}, 100%, 70%, ${alpha})`;
            ctx.lineWidth = 2;
            
            switch(type) {
                case 'tetrahedron':
                    // Draw tetrahedron
                    const h = size * Math.sqrt(6) / 3;
                    ctx.beginPath();
                    for(let i = 0; i < 3; i++) {
                        const angle = (i / 3) * Math.PI * 2;
                        const px = Math.cos(angle) * size;
                        const py = Math.sin(angle) * size;
                        if(i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.moveTo(0, -h);
                    for(let i = 0; i < 3; i++) {
                        const angle = (i / 3) * Math.PI * 2;
                        const px = Math.cos(angle) * size;
                        const py = Math.sin(angle) * size;
                        ctx.lineTo(px, py);
                        ctx.moveTo(0, -h);
                    }
                    ctx.stroke();
                    break;
                    
                case 'cube':
                    // Draw cube
                    ctx.strokeRect(-size/2, -size/2, size, size);
                    ctx.beginPath();
                    ctx.moveTo(-size/4, -size/4);
                    ctx.lineTo(size/4, -size/4);
                    ctx.lineTo(size/4, size/4);
                    ctx.lineTo(-size/4, size/4);
                    ctx.closePath();
                    ctx.stroke();
                    break;
                    
                case 'octahedron':
                    // Draw octahedron
                    ctx.beginPath();
                    ctx.moveTo(0, -size);
                    ctx.lineTo(size, 0);
                    ctx.lineTo(0, size);
                    ctx.lineTo(-size, 0);
                    ctx.closePath();
                    ctx.moveTo(0, -size);
                    ctx.lineTo(-size, 0);
                    ctx.moveTo(0, size);
                    ctx.lineTo(size, 0);
                    ctx.stroke();
                    break;
                    
                case 'dodecahedron':
                    // Draw simplified dodecahedron
                    const r = size * 0.8;
                    ctx.beginPath();
                    for(let i = 0; i < 5; i++) {
                        const angle = (i / 5) * Math.PI * 2;
                        const px = Math.cos(angle) * r;
                        const py = Math.sin(angle) * r;
                        if(i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.stroke();
                    
                    const innerR = r * 0.6;
                    ctx.beginPath();
                    for(let i = 0; i < 5; i++) {
                        const angle = (i / 5) * Math.PI * 2 + Math.PI / 5;
                        const px = Math.cos(angle) * innerR;
                        const py = Math.sin(angle) * innerR;
                        if(i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.stroke();
                    break;
            }
            
            ctx.restore();
        }

        // Main animation loop
        function drawOortCloud(timestamp) {
            const time = timestamp * 0.001;
            
            // Clear core canvas
            coreCtx.clearRect(0, 0, coreCanvas.width, coreCanvas.height);
            
            // Clear trail canvas with fade
            trailCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            trailCtx.fillRect(0, 0, trailCanvas.width, trailCanvas.height);

            // Update diving state
            updateDiving(time);
            
            // Update and draw psi-boids
            psiBoids.forEach(boid => {
                boid.update(psiBoids, time);
                boid.draw(coreCtx);
            });

            // Draw the core with enhanced effects
            const coreGlow = coreCtx.createRadialGradient(
                coreCanvas.width/2, coreCanvas.height/2, 0,
                coreCanvas.width/2, coreCanvas.height/2, 200
            );
            coreGlow.addColorStop(0, `hsla(180, 100%, 50%, ${0.3 + Math.sin(time) * 0.1})`);
            coreGlow.addColorStop(0.5, `hsla(180, 100%, 30%, ${0.2 + diveDepth * 0.3})`);
            coreGlow.addColorStop(1, 'transparent');
            
            coreCtx.fillStyle = coreGlow;
            coreCtx.beginPath();
            coreCtx.arc(coreCanvas.width/2, coreCanvas.height/2, 200, 0, Math.PI * 2);
            coreCtx.fill();

            // Draw dimensional echoes with enhanced visibility
            dimensionalEchoes = dimensionalEchoes.filter(echo => echo.strength > 0.1);
            dimensionalEchoes.forEach(echo => {
                echo.draw(trailCtx, time);
                
                // Add connecting lines to nearby echoes for dimensional mapping
                dimensionalEchoes.forEach(other => {
                    if (echo === other) return;
                    const dx = echo.x - other.x;
                    const dy = echo.y - other.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 200) {
                        trailCtx.beginPath();
                        trailCtx.moveTo(echo.x, echo.y);
                        trailCtx.lineTo(other.x, other.y);
                        trailCtx.strokeStyle = `hsla(${180 + echo.dimension * 30}, 100%, 70%, ${echo.strength * 0.2 * visualParams.echoPersistence})`;
                        trailCtx.lineWidth = 1;
                        trailCtx.stroke();
                    }
                });
            });

            // Draw quantum structures based on dive depth
            quantumStructures.forEach((layer, layerIndex) => {
                const layerDepth = layerIndex + 1;
                if (diveDepth > layerDepth * 0.2) {
                    const layerAlpha = Math.min(1, (diveDepth - layerDepth * 0.2) * 2) * visualParams.traceDepth;
                    
                    layer.forEach(structure => {
                        const wobble = Math.sin(time * structure.frequency + structure.phase) * 10 * visualParams.stringResonance;
                        drawPlatonicSolid(
                            trailCtx,
                            structure.type,
                            structure.x + wobble,
                            structure.y + wobble,
                            structure.size * (1 + Math.sin(time + structure.phase) * 0.1),
                            structure.rotation + time * 0.1,
                            layerAlpha * 0.5
                        );
                    });
                }
            });

            requestAnimationFrame(drawOortCloud);
        }

        // Increase particle count and add deep structures
        const DEPTH_LAYERS = 5;
        
        // Diving mechanics
        function updateDiving(time) {
            // Clear previous frame with fade
            trailCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            trailCtx.fillRect(0, 0, trailCanvas.width, trailCanvas.height);
            
            // WASD/Arrow keys to swim with enhanced feedback
            const moveSpeed = 0.1 * (1 + playerEnergy);
            let dx = 0, dy = 0;
            
            if (keyState.has('w') || keyState.has('arrowup')) dy -= moveSpeed * 5;
            if (keyState.has('s') || keyState.has('arrowdown')) dy += moveSpeed * 5;
            if (keyState.has('a') || keyState.has('arrowleft')) dx -= moveSpeed * 5;
            if (keyState.has('d') || keyState.has('arrowright')) dx += moveSpeed * 5;
            
            // Update player position with momentum
            mouseX += dx;
            mouseY += dy;
            
            // Space to dive deeper with enhanced feedback
            if (keyState.has(' ')) {
                diveDepth += 0.02 * (1 + playerEnergy);
                dimensionalPhase += 0.01;
                
                // Add diving ripples
                const rippleCount = Math.floor(20 * diveDepth);
                for (let i = 0; i < rippleCount; i++) {
                    const ripplePhase = (time + i/rippleCount) * Math.PI * 2;
                    const rippleSize = (100 + Math.sin(ripplePhase) * 30) * (1 + diveDepth);
                    const alpha = 0.2 * (1 - i/rippleCount) * Math.sin(ripplePhase);
                    
                    trailCtx.strokeStyle = `hsla(${180 + i * 20}, 100%, 50%, ${alpha * visualParams.traceDepth})`;
                    trailCtx.lineWidth = 2;
                    trailCtx.beginPath();
                    trailCtx.arc(mouseX, mouseY, rippleSize, 0, Math.PI * 2);
                    trailCtx.stroke();
                }

                // Add quantum strings when diving deep
                if (diveDepth > 0.3) {
                    drawQuantumStrings(trailCtx, time);
                }
            } else {
                diveDepth *= 0.99;
            }

            // Update player energy with visual feedback
            if (mousePressed) {
                playerEnergy = Math.min(1, playerEnergy + 0.01);
            } else {
                playerEnergy *= 0.99;
            }

            // Apply diving effects to core view
            const scale = 1 + diveDepth;
            coreCtx.save();
            coreCtx.translate(coreCanvas.width/2, coreCanvas.height/2);
            coreCtx.scale(scale, scale);
            coreCtx.translate(-coreCanvas.width/2, -coreCanvas.height/2);
        }

        function drawQuantumStrings(ctx, time) {
            const stringCount = Math.floor(20 * visualParams.patternDensity);
            ctx.lineWidth = 1;
            
            for (let i = 0; i < stringCount; i++) {
                const phase = time + i * Math.PI * 2 / stringCount;
                const resonance = visualParams.stringResonance * 50;
                
                ctx.beginPath();
                for (let t = 0; t < Math.PI * 4; t += 0.1) {
                    const radius = 100 + Math.sin(t * 3 + phase) * resonance;
                    const x = coreCanvas.width/2 + Math.cos(t) * radius;
                    const y = coreCanvas.height/2 + Math.sin(t) * radius;
                    
                    if (t === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.strokeStyle = `hsla(${180 + i * 360/stringCount}, 100%, 50%, ${0.3 * visualParams.traceDepth})`;
                ctx.stroke();
            }
        }

        // Enhance updateDiving with new parameters
        function updateDiving(time) {
            // ... existing diving code ...

            // Add quantum strings when diving deep
            if (diveDepth > 0.3) {
                drawQuantumStrings(trailCtx, time);
            }

            // Adjust echo persistence
            dimensionalEchoes = dimensionalEchoes.filter(echo => 
                echo.strength > 0.1 * (1 - visualParams.echoPersistence)
            );

            // Enhance structure visibility with trace depth
            quantumStructures.forEach((layer, layerIndex) => {
                const layerDepth = layerIndex + 1;
                if (diveDepth > layerDepth * 0.2 * (1 - visualParams.traceDepth)) {
                    const layerAlpha = Math.min(1, (diveDepth - layerDepth * 0.2) * 2);
                    
                    layer.forEach(structure => {
                        const wobble = Math.sin(time * structure.frequency + structure.phase) 
                            * 10 * visualParams.stringResonance;
                        drawPlatonicSolid(
                            trailCtx,
                            structure.type,
                            structure.x + wobble,
                            structure.y + wobble,
                            structure.size * (1 + Math.sin(time + structure.phase) * 0.1),
                            structure.rotation + time * 0.1,
                            layerAlpha * 0.5 * visualParams.traceDepth
                        );
                    });
                }
            });
        }

        // Start the animation
        initCanvas();
        requestAnimationFrame(drawOortCloud);
    </script>
    <script>
        // Add instructions overlay
        const instructions = document.createElement('div');
        instructions.style.position = 'fixed';
        instructions.style.bottom = '20px';
        instructions.style.left = '20px';
        instructions.style.color = '#0ff';
        instructions.style.fontFamily = 'monospace';
        instructions.style.pointerEvents = 'none';
        instructions.innerHTML = `
            WASD/Arrows: Swim
            Space: Dive Deeper
            Click: Feed & Energize
            Follow the quantum fish...
        `;
        document.body.appendChild(instructions);

        // Add visualization controls
        const controls = document.createElement('div');
        controls.style.position = 'fixed';
        controls.style.right = '20px';
        controls.style.top = '20px';
        controls.style.background = 'rgba(0, 20, 20, 0.8)';
        controls.style.padding = '15px';
        controls.style.borderRadius = '10px';
        controls.style.color = '#0ff';
        controls.style.fontFamily = 'monospace';
        controls.innerHTML = `
            <div style="margin-bottom: 10px">Quantum Vision Controls</div>
            <div style="margin-bottom: 8px">
                <label>Trace Depth</label><br>
                <input type="range" id="traceDepth" min="0" max="100" value="50">
            </div>
            <div style="margin-bottom: 8px">
                <label>String Resonance</label><br>
                <input type="range" id="stringResonance" min="0" max="100" value="70">
            </div>
            <div style="margin-bottom: 8px">
                <label>Pattern Density</label><br>
                <input type="range" id="patternDensity" min="0" max="100" value="60">
            </div>
            <div>
                <label>Echo Persistence</label><br>
                <input type="range" id="echoPersistence" min="0" max="100" value="80">
            </div>
        `;
        document.body.appendChild(controls);

        // Update parameters from sliders
        ['traceDepth', 'stringResonance', 'patternDensity', 'echoPersistence'].forEach(param => {
            const slider = document.getElementById(param);
            slider.addEventListener('input', (e) => {
                visualParams[param] = e.target.value / 100;
            });
        });

        function drawQuantumStrings(ctx, time) {
            const stringCount = Math.floor(20 * visualParams.patternDensity);
            ctx.lineWidth = 1;
            
            for (let i = 0; i < stringCount; i++) {
                const phase = time + i * Math.PI * 2 / stringCount;
                const resonance = visualParams.stringResonance * 50;
                
                ctx.beginPath();
                for (let t = 0; t < Math.PI * 4; t += 0.1) {
                    const radius = 100 + Math.sin(t * 3 + phase) * resonance;
                    const x = coreCanvas.width/2 + Math.cos(t) * radius;
                    const y = coreCanvas.height/2 + Math.sin(t) * radius;
                    
                    if (t === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.strokeStyle = `hsla(${180 + i * 360/stringCount}, 100%, 50%, ${0.3 * visualParams.traceDepth})`;
                ctx.stroke();
            }
        }

        // Enhance updateDiving with new parameters
        function updateDiving(time) {
            // ... existing diving code ...

            // Add quantum strings when diving deep
            if (diveDepth > 0.3) {
                drawQuantumStrings(trailCtx, time);
            }

            // Adjust echo persistence
            dimensionalEchoes = dimensionalEchoes.filter(echo => 
                echo.strength > 0.1 * (1 - visualParams.echoPersistence)
            );

            // Enhance structure visibility with trace depth
            quantumStructures.forEach((layer, layerIndex) => {
                const layerDepth = layerIndex + 1;
                if (diveDepth > layerDepth * 0.2 * (1 - visualParams.traceDepth)) {
                    const layerAlpha = Math.min(1, (diveDepth - layerDepth * 0.2) * 2);
                    
                    layer.forEach(structure => {
                        const wobble = Math.sin(time * structure.frequency + structure.phase) 
                            * 10 * visualParams.stringResonance;
                        drawPlatonicSolid(
                            trailCtx,
                            structure.type,
                            structure.x + wobble,
                            structure.y + wobble,
                            structure.size * (1 + Math.sin(time + structure.phase) * 0.1),
                            structure.rotation + time * 0.1,
                            layerAlpha * 0.5 * visualParams.traceDepth
                        );
                    });
                }
            });
        }
    </script>
</body>
</html>
