<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HyperGrid Core</title>
    <style>
        /* Original styles */
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100vw;
            height: 100vh;
        }
        
        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }
        
        #quantum-navigator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 200px;
            border: 2px solid rgba(0, 255, 255, 0.2);
            border-radius: 50%;
            cursor: crosshair;
            background: radial-gradient(circle at 50% 50%,
                rgba(255, 255, 255, 0.1),
                rgba(0, 100, 255, 0.15),
                rgba(0, 0, 0, 0.5)
            );
            box-shadow: 0 0 40px rgba(0, 100, 255, 0.2);
            z-index: 1000;
            touch-action: none;
            pointer-events: auto;
        }

        #navigator-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            pointer-events: none;
        }

        #navigator-grid::before,
        #navigator-grid::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.1);
        }

        #navigator-grid::before {
            top: 50%;
            left: 0;
            width: 100%;
            height: 1px;
            transform: translateY(-50%);
        }

        #navigator-grid::after {
            top: 0;
            left: 50%;
            width: 1px;
            height: 100%;
            transform: translateX(-50%);
        }

        #navigator-vector {
            position: absolute;
            width: 6px;
            height: 6px;
            background: rgba(0, 255, 255, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px cyan;
        }

        #quantum-hud {
            position: fixed;
            top: 20px;
            left: 20px;
            font-family: 'Courier New', monospace;
            color: rgba(0, 255, 255, 0.8);
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            pointer-events: none;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(0, 255, 255, 0.2);
            backdrop-filter: blur(5px);
        }

        .quantum-coordinate {
            margin: 5px 0;
            display: flex;
            align-items: center;
        }

        .coordinate-label {
            width: 120px;
            opacity: 0.7;
        }

        .coordinate-value {
            font-family: 'Consolas', monospace;
            color: #0ff;
        }

        .manifold-info {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid rgba(0, 255, 255, 0.2);
        }

        .quantum-bar {
            width: 100px;
            height: 4px;
            background: rgba(0, 255, 255, 0.2);
            margin-left: 10px;
            border-radius: 2px;
            overflow: hidden;
        }

        .quantum-bar-fill {
            height: 100%;
            background: rgba(0, 255, 255, 0.8);
            transition: width 0.3s ease;
        }

        /* New Core Proximity Effect */
        .core-proximity {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100px;
            height: 100px;
            background: radial-gradient(circle at center,
                rgba(255, 0, 255, 0.2) 0%,
                rgba(0, 255, 255, 0.1) 50%,
                transparent 100%
            );
            border-radius: 50%;
            pointer-events: none;
            z-index: 999;
            opacity: 0;
            transition: all 0.3s ease;
        }

        .core-proximity.active {
            opacity: 1;
            width: 200px;
            height: 200px;
        }

        .core-indicator {
            position: fixed;
            top: 10px;
            right: 10px;
            font-family: 'Courier New', monospace;
            color: #ff00ff;
            text-shadow: 0 0 10px rgba(255, 0, 255, 0.5);
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
            border: 1px solid rgba(255, 0, 255, 0.3);
            display: none;
        }

        .core-indicator.visible {
            display: block;
        }

        /* Control panel styles */
        .control-panel {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            z-index: 1000;
        }

        .control-btn {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid rgba(0, 255, 255, 0.3);
            color: #0ff;
            padding: 8px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            transition: all 0.3s ease;
            min-width: 80px;
            text-align: center;
        }

        .control-btn:hover {
            background: rgba(0, 255, 255, 0.2);
            border-color: rgba(0, 255, 255, 0.5);
        }

        .control-btn.active {
            background: rgba(0, 255, 255, 0.3);
            border-color: rgba(0, 255, 255, 0.8);
        }

        /* Manifold visualization */
        .manifold-vis {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 300px;
            height: 200px;
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 15px;
            padding: 15px;
            backdrop-filter: blur(10px);
            display: none;
            z-index: 1000;
            transition: all 0.3s ease;
        }

        .manifold-stats {
            position: absolute;
            bottom: 10px;
            left: 15px;
            right: 15px;
            color: #0ff;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            display: flex;
            justify-content: space-between;
            opacity: 0.8;
        }

        .manifold-stats span {
            color: #f0f;
        }

        .manifold-axis-label {
            position: absolute;
            color: rgba(0, 255, 255, 0.6);
            font-family: 'Courier New', monospace;
            font-size: 10px;
        }

        .manifold-axis-label.x {
            bottom: 25px;
            left: 50%;
            transform: translateX(-50%);
        }

        .manifold-axis-label.y {
            top: 50%;
            left: 5px;
            transform: rotate(-90deg) translateX(-50%);
            transform-origin: left center;
        }

        .manifold-vis.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .manifold-canvas {
            width: 100%;
            height: 100%;
            border-radius: 10px;
        }

        .manifold-label {
            position: absolute;
            top: -20px;
            left: 15px;
            color: #0ff;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            opacity: 0.8;
        }

        /* Core visualization styles */
        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }
        
        .stats {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #0ff;
            font-family: 'Courier New', monospace;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 10px;
            z-index: 1;
        }

        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 1;
        }

        button {
            background: rgba(0, 0, 0, 0.7);
            color: #0ff;
            border: 1px solid rgba(0, 255, 255, 0.3);
            padding: 8px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            transition: all 0.3s ease;
        }

        button:hover {
            background: rgba(0, 255, 255, 0.1);
        }

        button.active {
            background: rgba(0, 255, 255, 0.2);
        }
        
        /* Quantum Interface Elements */
        .quantum-element {
            background: rgba(0, 40, 50, 0.8);
            border-radius: 50%;
            padding: 10px;
            transition: all 0.3s ease;
        }
        .quantum-element.expanded {
            border-radius: 10px;
            background: rgba(0, 40, 50, 0.95);
            backdrop-filter: blur(5px);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
        }
        .quantum-icon {
            font-size: 24px;
            text-align: center;
        }
        .quantum-panel {
            display: none;
            padding: 10px;
            color: #0ff;
            font-family: monospace;
        }
        .expanded .quantum-panel {
            display: block;
        }
        .quantum-header {
            border-bottom: 1px solid #0ff;
            padding-bottom: 5px;
            margin-bottom: 5px;
        }
        .quantum-content {
            min-width: 200px;
            min-height: 100px;
        }
        
        .coordinate-display {
            position: fixed;
            bottom: 20px;
            right: 20px;
            color: #0ff;
            font-family: monospace;
            font-size: 14px;
            text-align: right;
            pointer-events: none;
            z-index: 1000;
            text-shadow: 0 0 5px rgba(0, 255, 255, 0.5);
        }
    </style>
</head>
<body>
    <div id="quantum-navigator">
        <div id="navigator-grid"></div>
        <div id="navigator-vector"></div>
    </div>
    <div id="quantum-hud">
        <div class="quantum-coordinate">
            <span class="coordinate-label">Phase:</span>
            <span class="coordinate-value">0.00π</span>
        </div>
        <div class="quantum-coordinate">
            <span class="coordinate-label">Spin:</span>
            <span class="coordinate-value">↑</span>
        </div>
        <div class="quantum-coordinate">
            <span class="coordinate-label">Entangled:</span>
            <span class="coordinate-value">No</span>
        </div>
        <div class="manifold-info">
            <div class="quantum-coordinate">
                <span class="coordinate-label">Manifold Depth:</span>
                <span class="coordinate-value" id="manifold-depth">λ=0.800</span>
            </div>
            <div class="quantum-coordinate">
                <span class="coordinate-label">Curvature:</span>
                <span class="coordinate-value" id="curvature">κ=1.400</span>
            </div>
            <div class="quantum-coordinate">
                <span class="coordinate-label">Q-Entropy:</span>
                <span class="coordinate-value" id="q-entropy">1.317 qbits</span>
            </div>
        </div>
    </div>
    <div class="core-proximity"></div>
    <div class="core-indicator">CORE PROXIMITY ALERT v2.1</div>

    <!-- Control Panel -->
    <div class="control-panel">
        <div class="control-btn" id="homeBtn">HOME</div>
        <div class="control-btn" id="stopBtn">STOP</div>
        <div class="control-btn" id="manifoldBtn">MANIFOLD</div>
    </div>

    <!-- Manifold Visualization -->
    <div class="manifold-vis">
        <div class="manifold-label">MANIFOLD TOPOLOGY</div>
        <canvas id="manifoldCanvas" class="manifold-canvas"></canvas>
        <div class="manifold-axis-label x">SPATIAL POSITION</div>
        <div class="manifold-axis-label y">CURVATURE</div>
        <div class="manifold-stats">
            <div>λ=<span id="manifoldDepth">0.000</span></div>
            <div>κ=<span id="manifoldCurv">0.000</span></div>
            <div>∇=<span id="manifoldGrad">0.000</span></div>
        </div>
    </div>

    <div class="coordinate-display">
        <div class="manifold-depth">λ=0.000</div>
        <div class="curvature">κ=1.400</div>
        <div class="q-entropy">1.317 qbits</div>
    </div>

    <script>
        // Global variables
        let coreCanvas, coreCtx;
        const psiBoids = [];
        let time = 0;
        let roark;
        let keyState = new Set();
        let isDragging = false;
        let mouseX = 0;
        let mouseY = 0;
        
        // Quantum state
        let quantumState = {
            phase: 0,
            resonance: 1.0,
            entanglement: 0,
            depth: 0,
            geometryLayer: 0,
            diving: false,
            diveStartTime: 0,
            initialDepth: 0
        };

        // Visual parameters
        const visualParams = {
            traceDepth: 0.5,
            stringResonance: 0.7,
            patternDensity: 0.6,
            echoPersistence: 0.4
        };

        // Ancient geometry patterns
        const deepGeometries = [
            {pattern: 'tetrahedron', frequency: 1.618033988749895},
            {pattern: 'cube', frequency: 2.449489742783178},
            {pattern: 'octahedron', frequency: 3.141592653589793},
            {pattern: 'dodecahedron', frequency: 4.236067977499790},
            {pattern: 'icosahedron', frequency: 5.0}
        ];

        // Mouse event listeners
        window.addEventListener('mousemove', e => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        window.addEventListener('mousedown', () => {
            isDragging = true;
        });

        window.addEventListener('mouseup', () => {
            isDragging = false;
        });

        // Initialize everything
        function initCore() {
            // Create canvas
            coreCanvas = document.createElement('canvas');
            coreCanvas.width = window.innerWidth;
            coreCanvas.height = window.innerHeight;
            document.body.appendChild(coreCanvas);
            coreCtx = coreCanvas.getContext('2d');
            
            // Set canvas style
            coreCanvas.style.position = 'absolute';
            coreCanvas.style.top = '0';
            coreCanvas.style.left = '0';
            coreCanvas.style.background = '#000';
            
            // Initialize psiboids
            initPsiboids();
            
            // Initialize interface elements
            initInterface();
            initSliders();
            
            // Start animation loop
            function updateFrame() {
                // Clear with fade effect
                coreCtx.fillStyle = `rgba(0, 0, 0, ${1 - visualParams.echoPersistence})`;
                coreCtx.fillRect(0, 0, coreCanvas.width, coreCanvas.height);
                
                // Update quantum state
                time++;
                quantumState.phase += 0.01;
                
                // Update all psiboids
                psiBoids.forEach(psiboid => psiboid.update());
                
                // Create quantum bridges
                if (psiBoids[0]) {
                    let nearestPsiboid = findNearestPsiboid(psiBoids[0].x, psiBoids[0].y);
                    if (nearestPsiboid) {
                        createQuantumBridge(
                            psiBoids[0].x, psiBoids[0].y,
                            nearestPsiboid.x, nearestPsiboid.y,
                            1 - Math.min(1, Math.hypot(psiBoids[0].x - nearestPsiboid.x, psiBoids[0].y - nearestPsiboid.y) / 300)
                        );
                    }
                }
                
                // Update manifold display
                updateManifold();
                
                // Request next frame
                requestAnimationFrame(updateFrame);
            }
            
            // Start the animation
            updateFrame();
        }

        // Initialize HTML elements
        function initInterface() {
            // Create manifold display
            const manifoldDisplay = document.createElement('div');
            manifoldDisplay.style.position = 'fixed';
            manifoldDisplay.style.right = '20px';
            manifoldDisplay.style.top = '20px';
            manifoldDisplay.style.color = '#00ffff';
            manifoldDisplay.style.fontFamily = 'monospace';
            manifoldDisplay.style.textAlign = 'right';
            manifoldDisplay.innerHTML = `
                <div class="manifold-depth">λ=0.000</div>
                <div class="curvature">κ=1.400</div>
                <div class="q-entropy">1.317 qbits</div>
            `;
            document.body.appendChild(manifoldDisplay);

            // Create control buttons
            const controls = document.createElement('div');
            controls.style.position = 'fixed';
            controls.style.bottom = '20px';
            controls.style.left = '50%';
            controls.style.transform = 'translateX(-50%)';
            controls.style.display = 'flex';
            controls.style.gap = '10px';
            controls.innerHTML = `
                <button onclick="homeState()" style="background: #001414; color: #00ffff; border: 1px solid #00ffff; padding: 10px 20px; cursor: pointer;">HOME</button>
                <button onclick="stopState()" style="background: #001414; color: #00ffff; border: 1px solid #00ffff; padding: 10px 20px; cursor: pointer;">STOP</button>
                <button onclick="toggleManifold()" style="background: #001414; color: #00ffff; border: 1px solid #00ffff; padding: 10px 20px; cursor: pointer;">MANIFOLD</button>
            `;
            document.body.appendChild(controls);
        }

        // Psiboid creation
        function createPsiboid() {
            return {
                x: Math.random() * window.innerWidth,
                y: Math.random() * window.innerHeight,
                vx: (Math.random() - 0.5) * 4,
                vy: (Math.random() - 0.5) * 4,
                size: 5 + Math.random() * 5,
                phase: Math.random() * Math.PI * 2,
                frequency: 0.02 + Math.random() * 0.03,
                resonance: 0.8 + Math.random() * 0.4,
                trail: [],
                maxTrailLength: 20,
                submergedDepth: 0,
                resonanceField: Array(6).fill(0),
                
                update() {
                    // Update position with quantum effects
                    const uncertainty = 0.5 * (1 - this.submergedDepth);
                    this.vx += (Math.random() - 0.5) * uncertainty;
                    this.vy += (Math.random() - 0.5) * uncertainty;
                    
                    // Apply velocity limits
                    const maxSpeed = 2 + this.submergedDepth * 1.5;
                    const speed = Math.hypot(this.vx, this.vy);
                    if (speed > maxSpeed) {
                        this.vx = (this.vx / speed) * maxSpeed;
                        this.vy = (this.vy / speed) * maxSpeed;
                    }
                    
                    // Update position
                    this.x += this.vx;
                    this.y += this.vy;
                    
                    // Wrap around edges with quantum tunneling
                    const margin = 50;
                    if (this.x < -margin) this.x = window.innerWidth + margin;
                    if (this.x > window.innerWidth + margin) this.x = -margin;
                    if (this.y < -margin) this.y = window.innerHeight + margin;
                    if (this.y > window.innerHeight + margin) this.y = -margin;
                    
                    // Update phase and resonance
                    this.phase += this.frequency;
                    this.resonance = 0.8 + 0.2 * Math.sin(this.phase);
                    
                    // Update trail with quantum effects
                    this.trail.unshift({
                        x: this.x + (Math.random() - 0.5) * 2 * (1 - this.submergedDepth),
                        y: this.y + (Math.random() - 0.5) * 2 * (1 - this.submergedDepth),
                        phase: this.phase
                    });
                    
                    if (this.trail.length > this.maxTrailLength) {
                        this.trail.pop();
                    }
                    
                    // Update resonance field
                    for (let i = 0; i < this.resonanceField.length; i++) {
                        const targetValue = 0.5 + 0.5 * Math.sin(this.phase + i * Math.PI / 3);
                        this.resonanceField[i] += (targetValue - this.resonanceField[i]) * 0.1;
                    }
                    
                    // Draw psiboid core
                    const glowSize = this.size * (1.5 + 0.5 * Math.sin(this.phase));
                    const alpha = 0.5 + 0.3 * Math.sin(this.phase);
                    
                    // Draw quantum glow
                    coreCtx.beginPath();
                    coreCtx.arc(this.x, this.y, glowSize, 0, Math.PI * 2);
                    coreCtx.fillStyle = `rgba(0, 255, 255, ${alpha * 0.3})`;
                    coreCtx.fill();
                    
                    // Draw core
                    coreCtx.beginPath();
                    coreCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    coreCtx.fillStyle = `rgba(0, 255, 255, ${alpha})`;
                    coreCtx.fill();
                    
                    // Draw quantum trail
                    if (this.trail.length > 1) {
                        coreCtx.beginPath();
                        coreCtx.moveTo(this.trail[0].x, this.trail[0].y);
                        
                        for (let i = 1; i < this.trail.length; i++) {
                            const point = this.trail[i];
                            const trailAlpha = (1 - i/this.trail.length) * 0.5;
                            
                            coreCtx.lineTo(point.x, point.y);
                            coreCtx.strokeStyle = `rgba(0, 255, 255, ${trailAlpha})`;
                            coreCtx.lineWidth = 2 * (1 - i/this.trail.length);
                            coreCtx.stroke();
                            coreCtx.beginPath();
                            coreCtx.moveTo(point.x, point.y);
                        }
                    }
                    
                    // Draw resonance field when submerged
                    if (this.submergedDepth > 0) {
                        coreCtx.beginPath();
                        this.resonanceField.forEach((val, i) => {
                            const angle = (i / 6) * Math.PI * 2;
                            const radius = 30 + val * 20;
                            const x = this.x + Math.cos(angle) * radius;
                            const y = this.y + Math.sin(angle) * radius;
                            
                            if (i === 0) {
                                coreCtx.moveTo(x, y);
                            } else {
                                coreCtx.lineTo(x, y);
                            }
                        });
                        coreCtx.closePath();
                        coreCtx.strokeStyle = `rgba(0, 255, 255, ${0.3 * this.submergedDepth})`;
                        coreCtx.stroke();
                    }
                }
            };
        }

        // Initialize psiboids
        function initPsiboids() {
            // Clear existing psiboids
            psiBoids.length = 0;
            
            // Create new psiboids
            for (let i = 0; i < 10; i++) {
                psiBoids.push(createPsiboid());
            }
        }

        // Update manifold display
        function updateManifold() {
            const depth = quantumState.depth;
            document.querySelector('.manifold-depth').textContent = 
                `λ=${depth.toFixed(3)}`;
            document.querySelector('.curvature').textContent = 
                `κ=${(1.4 + depth * 0.1).toFixed(3)}`;
            document.querySelector('.q-entropy').textContent = 
                `${(1.317 + depth * 0.05).toFixed(3)} qbits`;
        }

        // Control functions
        function homeState() {
            quantumState.depth = 0;
            quantumState.phase = 0;
            quantumState.resonance = 1.0;
        }

        function stopState() {
            psiBoids.forEach(psiboid => {
                psiboid.vx *= 0.1;
                psiboid.vy *= 0.1;
            });
        }

        function toggleManifold() {
            const display = document.querySelector('.manifold-depth').parentElement;
            display.style.display = display.style.display === 'none' ? 'block' : 'none';
        }

        // Quantum diving mechanics
        function quantumDive() {
            if (!quantumState.diving) {
                quantumState.diving = true;
                quantumState.diveStartTime = time;
                quantumState.initialDepth = quantumState.depth;
            }
            
            // Calculate dive progress
            const diveProgress = Math.min((time - quantumState.diveStartTime) / 60, 1);
            const targetDepth = quantumState.initialDepth + 1;
            
            // Smooth easing function for depth transition
            quantumState.depth = quantumState.initialDepth + (1 - Math.cos(diveProgress * Math.PI)) * 0.5;
            
            // Generate quantum foam particles
            const numParticles = Math.floor(50 * (1 + quantumState.depth));
            const centerX = window.innerWidth * 0.5;
            const centerY = window.innerHeight * 0.5;
            
            for (let i = 0; i < numParticles; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * window.innerWidth * 0.3 * (1 + quantumState.depth * 0.2);
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                
                const size = 1 + Math.random() * 2 * (1 + quantumState.depth * 0.5);
                const alpha = (0.3 + Math.random() * 0.7) * Math.min(1, quantumState.depth);
                
                coreCtx.beginPath();
                coreCtx.arc(x, y, size, 0, Math.PI * 2);
                coreCtx.fillStyle = `rgba(0, ${155 + Math.random() * 100}, ${255 * Math.random()}, ${alpha})`;
                coreCtx.fill();
            }
            
            // Create quantum ripples
            const ripples = 5 + Math.floor(quantumState.depth * 3);
            for (let i = 0; i < ripples; i++) {
                const radius = (100 + i * 50) * (1 + quantumState.depth * 0.3);
                const phase = (time * 0.01 + i * Math.PI / ripples) % (Math.PI * 2);
                
                coreCtx.beginPath();
                coreCtx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                coreCtx.strokeStyle = `rgba(0, 255, 255, ${0.2 * Math.sin(phase) * Math.min(1, quantumState.depth)})`;
                coreCtx.lineWidth = 2 + Math.sin(phase) * 2;
                coreCtx.stroke();
            }
            
            // Update psiboid behavior based on depth
            psiBoids.forEach(psiboid => {
                psiboid.maxSpeed = 2 + quantumState.depth * 1.5;
                psiboid.perception = 100 + quantumState.depth * 50;
                psiboid.glow = Math.min(1, quantumState.depth) * 20;
            });
            
            // Create quantum tunnels between psiboids
            if (quantumState.depth > 0.5) {
                psiBoids.forEach((psiboid, i) => {
                    const nextPsiboid = psiBoids[(i + 1) % psiBoids.length];
                    const strength = Math.min(1, (quantumState.depth - 0.5) * 2);
                    createQuantumBridge(psiboid.x, psiboid.y, nextPsiboid.x, nextPsiboid.y, strength);
                });
            }
            
            // Update quantum state display
            document.querySelector('.manifold-depth').textContent = 
                `λ=${quantumState.depth.toFixed(3)}`;
            document.querySelector('.curvature').textContent = 
                `κ=${(1.4 + quantumState.depth * 0.1).toFixed(3)}`;
            document.querySelector('.q-entropy').textContent = 
                `${(1.317 + quantumState.depth * 0.05).toFixed(3)} qbits`;
        }

        // Add to event listeners
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                quantumDive();
            }
        });

        // Enhanced PsiBoid class with hyperstring connections
        class PsiBoid {
            constructor(x, y, type = 'normal') {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.type = type;
                this.energy = 1;
                this.connections = [];
                this.phase = Math.random() * Math.PI * 2;
                this.submergedDepth = Math.random();
                this.fluidInfluence = 0;
                this.resonanceField = new Array(6).fill(0);
                this.lastPositions = Array(5).fill({x: x, y: y}); // Trail positions
                this.quantumState = {
                    entanglement: 0,
                    geometryIndex: Math.floor(Math.random() * deepGeometries.length),
                    phaseAlignment: Math.random() * Math.PI * 2
                };
            }

            update() {
                // Update quantum state
                this.phase += 0.05;
                this.updateResonanceField();
                
                if (this.type === 'guardian') {
                    // Quantum navigation
                    const resonanceStrength = quantumState.resonance * (1 + quantumState.depth * 0.2);
                    
                    // Follow psiboid quantum paths
                    let nearestPsiboid = null;
                    let minDist = Infinity;
                    psiBoids.forEach(other => {
                        if (other !== this) {
                            const dx = other.x - this.x;
                            const dy = other.y - this.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < minDist) {
                                minDist = dist;
                                nearestPsiboid = other;
                            }
                        }
                    });

                    if (nearestPsiboid) {
                        // Quantum tunneling to nearest psiboid
                        if (keyState.has('w')) {
                            this.quantumTunnel(nearestPsiboid, resonanceStrength);
                        }
                        // Phase alignment for deep diving
                        if (keyState.has('s')) {
                            this.alignPhase(nearestPsiboid, resonanceStrength);
                        }
                        // Geometric rotation
                        if (keyState.has('a')) {
                            quantumState.geometryLayer = (quantumState.geometryLayer - 1 + deepGeometries.length) % deepGeometries.length;
                        }
                        if (keyState.has('d')) {
                            quantumState.geometryLayer = (quantumState.geometryLayer + 1) % deepGeometries.length;
                        }
                    }

                    // Deep diving
                    if (keyState.has(' ')) {
                        quantumState.depth = Math.min(quantumState.depth + 0.05, 1);
                        this.submergedDepth = Math.min(this.submergedDepth + 0.05, 1);
                    } else {
                        quantumState.depth = Math.max(quantumState.depth - 0.05, 0);
                        this.submergedDepth = Math.max(this.submergedDepth - 0.05, 0);
                    }
                } else {
                    // Normal psiboid quantum behavior
                    this.quantumState.entanglement = Math.min(
                        this.quantumState.entanglement + 
                        Math.sin(this.phase + quantumState.phase) * 0.1, 
                        1
                    );
                    
                    const geometry = deepGeometries[this.quantumState.geometryIndex];
                    const geometricForce = Math.sin(time * 0.001 * geometry.frequency + this.phase) * 
                                        (1 + quantumState.depth * 0.5);

                    this.vx += Math.cos(this.quantumState.phaseAlignment) * geometricForce * 0.1;
                    this.vy += Math.sin(this.quantumState.phaseAlignment) * geometricForce * 0.1;
                    
                    // Update position with quantum influence
                    this.x += this.vx * (1 - quantumState.depth * 0.3);
                    this.y += this.vy * (1 - quantumState.depth * 0.3);
                    
                    // Apply quantum damping
                    this.vx *= 0.99 - (quantumState.depth * 0.02);
                    this.vy *= 0.99 - (quantumState.depth * 0.02);
                }

                // Update position history
                this.lastPositions.pop();
                this.lastPositions.unshift({x: this.x, y: this.y});
                
                this.updateConnections();
            }

            quantumTunnel(target, strength) {
                const dx = target.x - this.x;
                const dy = target.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const tunnelProb = Math.exp(-dist / (200 * strength));
                
                if (Math.random() < tunnelProb) {
                    this.x = target.x - dx * 0.1;
                    this.y = target.y - dy * 0.1;
                    this.quantumState.entanglement = Math.min(this.quantumState.entanglement + 0.2, 1);
                }
            }

            alignPhase(target, strength) {
                const phaseDiff = target.phase - this.phase;
                this.phase += phaseDiff * 0.1 * strength;
                this.quantumState.phaseAlignment = (this.quantumState.phaseAlignment + target.quantumState.phaseAlignment) / 2;
            }

            updateResonanceField() {
                // Update resonance field based on nearby psiboids
                this.resonanceField = this.resonanceField.map((val, i) => {
                    const angle = (i / 6) * Math.PI * 2;
                    let resonance = 0;
                    
                    this.connections.forEach(other => {
                        const dx = other.x - this.x;
                        const dy = other.y - this.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const angleToOther = Math.atan2(dy, dx);
                        const angleDiff = Math.abs(angleToOther - angle);
                        resonance += Math.exp(-dist/100) * Math.exp(-angleDiff);
                    });
                    
                    return val * 0.8 + resonance * 0.2;
                });
            }

            updateConnections() {
                // Find nearby psiboids for hyperstring connections
                const nearbyPsiboids = psiBoids.filter(other => {
                    if (other === this) return false;
                    const dx = other.x - this.x;
                    const dy = other.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    return dist < 150; // Connection range
                });

                // Update connections with fluid dynamics influence
                this.connections = nearbyPsiboids.map(other => {
                    const dx = other.x - this.x;
                    const dy = other.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    return {
                        psiboid: other,
                        dist: dist,
                        strength: Math.exp(-dist / 100) * (1 + this.fluidInfluence),
                        phase: Math.atan2(dy, dx) + this.phase
                    };
                });
            }

            draw() {
                const depth = quantumState.depth;
                const depthScale = 1 + (this.submergedDepth * depth * 0.1);
                
                // Draw fluid trails
                if (this.fluidInfluence > 0) {
                    coreCtx.beginPath();
                    this.lastPositions.forEach((pos, i) => {
                        const alpha = (1 - i/this.lastPositions.length) * 0.3 * this.fluidInfluence;
                        if (i === 0) {
                            coreCtx.moveTo(pos.x, pos.y);
                        } else {
                            coreCtx.lineTo(pos.x, pos.y);
                        }
                    });
                    coreCtx.strokeStyle = `rgba(100, 200, 255, ${this.fluidInfluence * 0.3})`;
                    coreCtx.lineWidth = 2;
                    coreCtx.stroke();
                }

                // Draw hyperstring connections with fluid influence
                this.connections.forEach((connection) => {
                    const other = connection.psiboid;
                    const dx = other.x - this.x;
                    const dy = other.y - this.y;
                    const strength = connection.strength;
                    
                    // Create hyperstring effect with fluid dynamics
                    const segments = 12;
                    coreCtx.beginPath();
                    
                    // Enhanced wave patterns
                    for (let j = 0; j <= segments; j++) {
                        const t = j/segments;
                        // Multiple wave frequencies for more organic look
                        const wave = (
                            Math.sin(t * Math.PI * 4 + this.phase + time * 0.001) * 3 +
                            Math.sin(t * Math.PI * 2 + this.phase * 1.5 + time * 0.002) * 2
                        ) * (1 + this.fluidInfluence);
                        
                        // Fluid motion influence
                        const fluid = (
                            Math.sin(t * Math.PI * 2 + time * 0.002) * 2 +
                            Math.cos(t * Math.PI * 3 + time * 0.001) * 1.5
                        ) * this.fluidInfluence;
                        
                        // Quantum interference patterns
                        const quantum = Math.sin(t * Math.PI * 6 + this.phase * 2) * 
                                     Math.cos(time * 0.003) * this.fluidInfluence * 2;
                        
                        const x = this.x + dx * t + 
                                Math.cos(connection.phase + t * Math.PI) * wave +
                                Math.sin(time * 0.001 + t * Math.PI) * fluid +
                                Math.cos(t * Math.PI * 3) * quantum;
                        const y = this.y + dy * t + 
                                Math.sin(connection.phase + t * Math.PI) * wave +
                                Math.cos(time * 0.001 + t * Math.PI) * fluid +
                                Math.sin(t * Math.PI * 3) * quantum;
                        
                        if (j === 0) coreCtx.moveTo(x, y);
                        else coreCtx.lineTo(x, y);
                    }
                    
                    // Create glowing effect for strings
                    const gradient = coreCtx.createLinearGradient(
                        this.x, this.y, 
                        this.x + dx, this.y + dy
                    );
                    
                    const alpha = strength * 0.4 * (1 + this.fluidInfluence * 0.5);
                    gradient.addColorStop(0, `rgba(100, 200, 255, ${alpha})`);
                    gradient.addColorStop(0.5, `rgba(150, 230, 255, ${alpha * 0.7})`);
                    gradient.addColorStop(1, `rgba(100, 200, 255, ${alpha})`);
                    
                    coreCtx.strokeStyle = gradient;
                    coreCtx.lineWidth = 1.5 * (1 + this.fluidInfluence * 0.5);
                    coreCtx.stroke();
                    
                    // Add subtle glow effect
                    coreCtx.strokeStyle = `rgba(150, 230, 255, ${alpha * 0.3})`;
                    coreCtx.lineWidth = 4 * (1 + this.fluidInfluence * 0.5);
                    coreCtx.stroke();
                });

                // Draw resonance field
                if (quantumState.depth > 0) {
                    coreCtx.beginPath();
                    this.resonanceField.forEach((val, i) => {
                        const angle = (i / 6) * Math.PI * 2;
                        const radius = 20 * (1 + val) * depthScale;
                        const x = this.x + Math.cos(angle) * radius;
                        const y = this.y + Math.sin(angle) * radius;
                        
                        if (i === 0) coreCtx.moveTo(x, y);
                        else coreCtx.lineTo(x, y);
                    });
                    coreCtx.closePath();
                    coreCtx.strokeStyle = `rgba(150, 255, 255, ${0.3 * this.fluidInfluence})`;
                    coreCtx.stroke();
                }

                // Draw core with fluid influence
                const coreSize = 4 * depthScale * (1 + this.fluidInfluence * 0.5);
                const glowSize = coreSize * 2;
                
                // Draw glow
                const gradient = coreCtx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, glowSize
                );
                gradient.addColorStop(0, `rgba(150, 230, 255, ${0.5 + 0.5 * Math.sin(this.phase)})`);
                gradient.addColorStop(1, 'rgba(100, 200, 255, 0)');
                
                coreCtx.beginPath();
                coreCtx.arc(this.x, this.y, glowSize, 0, Math.PI * 2);
                coreCtx.fillStyle = gradient;
                coreCtx.fill();
                
                // Draw core
                coreCtx.beginPath();
                coreCtx.arc(this.x, this.y, coreSize, 0, Math.PI * 2);
                coreCtx.fillStyle = this.getTypeColor();
                coreCtx.fill();
            }

            getTypeColor() {
                const fluidBrightness = Math.floor(55 + this.fluidInfluence * 200);
                switch(this.type) {
                    case 'guardian': 
                        return `rgba(255, 255, 255, ${0.9 + this.fluidInfluence * 0.1})`;
                    case 'energy': 
                        return `rgba(0, ${fluidBrightness}, 255, ${0.5 + Math.sin(this.phase) * 0.2})`;
                    default: 
                        return `rgba(150, ${fluidBrightness}, 255, ${0.4 + Math.sin(this.phase) * 0.1})`;
                }
            }
        }

        // Initialize everything and get guardian reference
        let guardian;

        // Add event listeners
        window.addEventListener('keydown', e => {
            keyState.add(e.key.toLowerCase());
            
            // Handle quantum diving
            if (e.code === 'Space') {
                quantumDive();
            }
        });
        
        window.addEventListener('keyup', e => {
            keyState.delete(e.key.toLowerCase());
        });

        window.addEventListener('resize', () => {
            coreCanvas.width = window.innerWidth;
            coreCanvas.height = window.innerHeight;
        });

        // Initialize core systems
        window.addEventListener('load', () => {
            // Create canvas
            coreCanvas = document.createElement('canvas');
            coreCanvas.width = window.innerWidth;
            coreCanvas.height = window.innerHeight;
            document.body.appendChild(coreCanvas);
            coreCtx = coreCanvas.getContext('2d');
            
            // Set canvas style
            coreCanvas.style.position = 'absolute';
            coreCanvas.style.top = '0';
            coreCanvas.style.left = '0';
            coreCanvas.style.background = '#000';
            
            // Initialize systems in order
            initPsiboids();  // Create psiboids first
            initRoark();     // Initialize Roark to track psiboids
            initInterface(); // Create interface elements
            
            // Quantum state observer
            let lastObservationTime = time;
            let waveFunction = {
                collapsed: false,
                amplitude: 1.0,
                phase: 0,
                entanglementStrength: 0
            };
            
            // Start animation loop
            function updateFrame() {
                // Clear with quantum fade
                const fadeAlpha = 1 - (visualParams.echoPersistence * (1 + Math.sin(time * 0.01) * 0.1));
                coreCtx.fillStyle = `rgba(0, 0, 0, ${fadeAlpha})`;
                coreCtx.fillRect(0, 0, coreCanvas.width, coreCanvas.height);
                
                // Update quantum state
                time++;
                quantumState.phase += 0.01;
                
                // Check for wave function collapse
                if (time - lastObservationTime > 60) {
                    waveFunction.collapsed = false;
                    waveFunction.amplitude = Math.min(1.0, waveFunction.amplitude + 0.05);
                }
                
                // Update all psiboids with quantum effects
                psiBoids.forEach((psiboid, i) => {
                    // Apply quantum uncertainty
                    const uncertainty = waveFunction.collapsed ? 0.1 : 0.5;
                    psiboid.vx += (Math.random() - 0.5) * uncertainty;
                    psiboid.vy += (Math.random() - 0.5) * uncertainty;
                    
                    // Update with quantum state
                    psiboid.update();
                    
                    // Create quantum bridges between adjacent psiboids
                    if (i < psiBoids.length - 1) {
                        const nextPsiboid = psiBoids[i + 1];
                        const bridgeStrength = waveFunction.amplitude * 
                            (1 + Math.sin(quantumState.phase + i * Math.PI/psiBoids.length) * 0.3);
                        
                        createQuantumBridge(
                            psiboid.x, psiboid.y,
                            nextPsiboid.x, nextPsiboid.y,
                            bridgeStrength
                        );
                    }
                });
                
                // Update Roark with quantum effects
                if (roark && roark.update) {
                    roark.update();
                    
                    // Create quantum tail effect
                    if (roark.tail && roark.tail.length > 1) {
                        coreCtx.beginPath();
                        coreCtx.moveTo(roark.tail[0].x, roark.tail[0].y);
                        
                        for (let i = 1; i < roark.tail.length; i++) {
                            const point = roark.tail[i];
                            const alpha = (1 - i/roark.tail.length) * waveFunction.amplitude;
                            const width = (3 - i/roark.tail.length * 2) * waveFunction.amplitude;
                            
                            // Add quantum fluctuation
                            const fluctuation = Math.sin(time * 0.1 + i * 0.2) * 5 * (1 - waveFunction.collapsed);
                            point.x += fluctuation;
                            point.y += fluctuation;
                            
                            coreCtx.lineTo(point.x, point.y);
                            coreCtx.strokeStyle = `rgba(0, 255, 255, ${alpha})`;
                            coreCtx.lineWidth = width;
                            coreCtx.stroke();
                            coreCtx.beginPath();
                            coreCtx.moveTo(point.x, point.y);
                        }
                    }
                }
                
                // Handle quantum interaction
                coreCanvas.addEventListener('mousedown', () => {
                    waveFunction.collapsed = true;
                    waveFunction.amplitude = 0.3;
                    lastObservationTime = time;
                });
                
                // Update manifold display
                updateManifold();
                
                // Request next frame
                requestAnimationFrame(updateFrame);
            }
            
            // Start the animation
            updateFrame();
            
            // Add resize handler
            window.addEventListener('resize', () => {
                coreCanvas.width = window.innerWidth;
                coreCanvas.height = window.innerHeight;
            });
        });

        // Create quantum bridge with entanglement
        function createQuantumBridge(startX, startY, endX, endY, strength) {
            const segments = 20;
            const phase = quantumState.phase;
            const depth = quantumState.depth;
            
            // Draw main bridge
            coreCtx.beginPath();
            for (let i = 0; i <= segments; i++) {
                const t = i/segments;
                const x = startX + (endX - startX) * t;
                const y = startY + (endY - startY) * t;
                
                // Add quantum fluctuations
                const fluctuation = Math.sin(t * Math.PI * 6 + phase) * 
                                  Math.sin(time * 0.002) * 
                                  (10 + depth * 20);
                
                // Add spiral structure
                const spiralRadius = (1 - t) * t * 100 * (1 + depth);
                const spiralPhase = t * Math.PI * 8 + phase;
                const spiralX = Math.cos(spiralPhase) * spiralRadius;
                const spiralY = Math.sin(spiralPhase) * spiralRadius;
                
                if (i === 0) {
                    coreCtx.moveTo(x + fluctuation + spiralX, y + fluctuation + spiralY);
                } else {
                    coreCtx.lineTo(x + fluctuation + spiralX, y + fluctuation + spiralY);
                }
            }
            
            // Create quantum gradient
            const gradient = coreCtx.createLinearGradient(startX, startY, endX, endY);
            const alpha = strength * 0.4 * (1 + depth);
            
            gradient.addColorStop(0, `rgba(0, 255, 255, ${alpha})`);
            gradient.addColorStop(0.5, `rgba(100, 200, 255, ${alpha * 0.7})`);
            gradient.addColorStop(1, `rgba(0, 255, 255, ${alpha})`);
            
            coreCtx.strokeStyle = gradient;
            coreCtx.lineWidth = 2 * (1 + depth);
            coreCtx.stroke();
            
            // Add quantum glow
            coreCtx.shadowColor = 'rgba(0, 255, 255, 0.5)';
            coreCtx.shadowBlur = 10;
            coreCtx.stroke();
        }

        // Initialize Roark with quantum properties
        function initRoark() {
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            
            roark = {
                x: centerX,
                y: centerY,
                tail: [],
                maxTailLength: 50,
                phase: 0,
                resonance: 1.0,
                quantumState: {
                    entangled: false,
                    superposition: 0,
                    coherence: 1.0
                },
                
                update() {
                    // Update phase
                    this.phase += 0.05;
                    this.resonance = 0.8 + 0.2 * Math.sin(this.phase);
                    
                    // Track nearest psiboid with quantum effects
                    if (psiBoids[0]) {
                        const dx = psiBoids[0].x - this.x;
                        const dy = psiBoids[0].y - this.y;
                        const dist = Math.hypot(dx, dy);
                        
                        // Apply quantum uncertainty to movement
                        const uncertainty = 0.1 * (1 - this.quantumState.coherence);
                        const moveX = dx * 0.1 + (Math.random() - 0.5) * uncertainty;
                        const moveY = dy * 0.1 + (Math.random() - 0.5) * uncertainty;
                        
                        this.x += moveX;
                        this.y += moveY;
                        
                        // Update quantum state based on distance
                        this.quantumState.entangled = dist < 100;
                        this.quantumState.superposition = Math.max(0, 1 - dist/300);
                        this.quantumState.coherence = Math.max(0.2, 1 - dist/500);
                    }
                    
                    // Update quantum tail
                    this.tail.unshift({
                        x: this.x + (Math.random() - 0.5) * 2 * (1 - this.quantumState.coherence),
                        y: this.y + (Math.random() - 0.5) * 2 * (1 - this.quantumState.coherence),
                        phase: this.phase
                    });
                    
                    if (this.tail.length > this.maxTailLength) {
                        this.tail.pop();
                    }
                    
                    // Draw Roark with quantum effects
                    const glowSize = 5 * (1 + 0.5 * Math.sin(this.phase));
                    const alpha = 0.8 + 0.2 * Math.sin(this.phase);
                    
                    // Draw quantum glow
                    coreCtx.beginPath();
                    coreCtx.arc(this.x, this.y, glowSize * 2, 0, Math.PI * 2);
                    coreCtx.fillStyle = `rgba(0, 255, 255, ${alpha * 0.3})`;
                    coreCtx.fill();
                    
                    // Draw core
                    coreCtx.beginPath();
                    coreCtx.arc(this.x, this.y, glowSize, 0, Math.PI * 2);
                    coreCtx.fillStyle = `rgba(0, 255, 255, ${alpha})`;
                    coreCtx.fill();
                    
                    // Draw quantum tail
                    if (this.tail.length > 1) {
                        coreCtx.beginPath();
                        coreCtx.moveTo(this.tail[0].x, this.tail[0].y);
                        
                        for (let i = 1; i < this.tail.length; i++) {
                            const point = this.tail[i];
                            const tailPhase = point.phase + i * 0.1;
                            const alpha = (1 - i/this.tail.length) * this.quantumState.coherence;
                            const width = (3 - i/this.tail.length * 2) * this.quantumState.coherence;
                            
                            // Add quantum fluctuation
                            const fluctuation = Math.sin(tailPhase) * 5 * (1 - this.quantumState.coherence);
                            const x = point.x + fluctuation * Math.cos(tailPhase);
                            const y = point.y + fluctuation * Math.sin(tailPhase);
                            
                            coreCtx.lineTo(x, y);
                            coreCtx.strokeStyle = `rgba(0, 255, 255, ${alpha})`;
                            coreCtx.lineWidth = width;
                            coreCtx.stroke();
                            coreCtx.beginPath();
                            coreCtx.moveTo(x, y);
                        }
                    }
                    
                    // Draw entanglement effect when close to psiboids
                    if (this.quantumState.entangled && psiBoids[0]) {
                        const target = psiBoids[0];
                        const dx = target.x - this.x;
                        const dy = target.y - this.y;
                        const dist = Math.hypot(dx, dy);
                        const strength = Math.max(0, 1 - dist/100);
                        
                        coreCtx.beginPath();
                        coreCtx.moveTo(this.x, this.y);
                        
                        // Create quantum bridge
                        const segments = 10;
                        for (let i = 1; i <= segments; i++) {
                            const t = i/segments;
                            const x = this.x + dx * t;
                            const y = this.y + dy * t;
                            
                            // Add quantum fluctuation
                            const fluctuation = Math.sin(t * Math.PI * 2 + this.phase) * 10 * strength;
                            const fx = x + fluctuation * Math.cos(this.phase + t * Math.PI);
                            const fy = y + fluctuation * Math.sin(this.phase + t * Math.PI);
                            
                            coreCtx.lineTo(fx, fy);
                        }
                        
                        coreCtx.strokeStyle = `rgba(0, 255, 255, ${0.3 * strength})`;
                        coreCtx.lineWidth = 2 * strength;
                        coreCtx.stroke();
                    }
                }
            };
            
            // Return Roark instance
            return roark;
        }
    </script>
</body>
</html>
