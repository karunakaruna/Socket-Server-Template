<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HyperGrid Core</title>
    <style>
        /* Original styles */
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100vw;
            height: 100vh;
        }
        
        canvas {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 0;
        }

        #quantum-navigator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 200px;
            border: 2px solid rgba(0, 255, 255, 0.2);
            border-radius: 50%;
            cursor: crosshair;
            background: radial-gradient(circle at 50% 50%,
                rgba(255, 255, 255, 0.1),
                rgba(0, 100, 255, 0.15),
                rgba(0, 0, 0, 0.5)
            );
            box-shadow: 0 0 40px rgba(0, 100, 255, 0.2);
            z-index: 1000;
            touch-action: none;
            pointer-events: auto;
        }

        #navigator-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            pointer-events: none;
        }

        #navigator-grid::before,
        #navigator-grid::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.1);
        }

        #navigator-grid::before {
            top: 50%;
            left: 0;
            width: 100%;
            height: 1px;
            transform: translateY(-50%);
        }

        #navigator-grid::after {
            top: 0;
            left: 50%;
            width: 1px;
            height: 100%;
            transform: translateX(-50%);
        }

        #navigator-vector {
            position: absolute;
            width: 6px;
            height: 6px;
            background: rgba(0, 255, 255, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px cyan;
        }

        #quantum-hud {
            position: fixed;
            top: 20px;
            left: 20px;
            font-family: 'Courier New', monospace;
            color: rgba(0, 255, 255, 0.8);
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            pointer-events: none;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(0, 255, 255, 0.2);
            backdrop-filter: blur(5px);
        }

        .quantum-coordinate {
            margin: 5px 0;
            display: flex;
            align-items: center;
        }

        .coordinate-label {
            width: 120px;
            opacity: 0.7;
        }

        .coordinate-value {
            font-family: 'Consolas', monospace;
            color: #0ff;
        }

        .manifold-info {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid rgba(0, 255, 255, 0.2);
        }

        .quantum-bar {
            width: 100px;
            height: 4px;
            background: rgba(0, 255, 255, 0.2);
            margin-left: 10px;
            border-radius: 2px;
            overflow: hidden;
        }

        .quantum-bar-fill {
            height: 100%;
            background: rgba(0, 255, 255, 0.8);
            transition: width 0.3s ease;
        }

        /* New Core Proximity Effect */
        .core-proximity {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100px;
            height: 100px;
            background: radial-gradient(circle at center,
                rgba(255, 0, 255, 0.2) 0%,
                rgba(0, 255, 255, 0.1) 50%,
                transparent 100%
            );
            border-radius: 50%;
            pointer-events: none;
            z-index: 999;
            opacity: 0;
            transition: all 0.3s ease;
        }

        .core-proximity.active {
            opacity: 1;
            width: 200px;
            height: 200px;
        }

        .core-indicator {
            position: fixed;
            top: 10px;
            right: 10px;
            font-family: 'Courier New', monospace;
            color: #ff00ff;
            text-shadow: 0 0 10px rgba(255, 0, 255, 0.5);
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
            border: 1px solid rgba(255, 0, 255, 0.3);
            display: none;
        }

        .core-indicator.visible {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    <div id="quantum-navigator">
        <div id="navigator-grid"></div>
        <div id="navigator-vector"></div>
    </div>
    <div id="quantum-hud">
        <div class="quantum-coordinate">
            <span class="coordinate-label">Phase:</span>
            <span class="coordinate-value">0.00π</span>
        </div>
        <div class="quantum-coordinate">
            <span class="coordinate-label">Spin:</span>
            <span class="coordinate-value">↑</span>
        </div>
        <div class="quantum-coordinate">
            <span class="coordinate-label">Entangled:</span>
            <span class="coordinate-value">No</span>
        </div>
        <div class="manifold-info">
            <div class="quantum-coordinate">
                <span class="coordinate-label">Manifold Depth:</span>
                <span class="coordinate-value">λ=0.800</span>
            </div>
            <div class="quantum-coordinate">
                <span class="coordinate-label">Curvature:</span>
                <span class="coordinate-value">κ=1.400</span>
            </div>
            <div class="quantum-coordinate">
                <span class="coordinate-label">Q-Entropy:</span>
                <span class="coordinate-value">1.317 qbits</span>
            </div>
        </div>
    </div>
    <div class="core-proximity"></div>
    <div class="core-indicator">CORE PROXIMITY ALERT v2.1</div>
    <script>
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl');

        if (!gl) {
            alert('WebGL not available');
            throw new Error('WebGL not available');
        }

        // Enhanced vertex shader with quantum effects
        const vertexShaderSource = `
            precision mediump float;
            
            attribute vec4 position;
            attribute vec4 color;
            attribute float size;
            
            uniform mat4 matrix;
            uniform float wProjection;
            uniform float hyperCurvature;
            uniform float time;
            uniform float focalLength;
            
            varying vec4 vColor;
            varying float vSize;
            varying float vDist;
            
            // Quantum noise function
            float quantum_noise(vec4 pos) {
                float t = time * 0.001;
                return sin(pos.x * 10.0 + t) * cos(pos.y * 10.0 - t) * sin(pos.z * 10.0 + pos.w * 10.0);
            }
            
            void main() {
                // Apply 4D rotation
                vec4 pos = position;
                pos = matrix * pos;
                float dist = length(pos.xyz);
                
                // Enhanced quantum effects near core
                float coreProximity = smoothstep(0.001, 0.2, wProjection);
                float quantumEffect = quantum_noise(pos) * (1.0 - coreProximity) * 0.1;
                pos.xyz += pos.xyz * quantumEffect;
                
                // Enhanced hyperbolic distortion with focal length
                float hyperEffect = 1.0 / (1.0 + dist * hyperCurvature * focalLength);
                pos.xyz *= hyperEffect;
                
                // Enhanced w-projection with quantum tunneling
                float w = mix(0.1, 2.0, wProjection + quantumEffect);
                gl_Position = vec4(pos.xyz * focalLength / (w - pos.w), 1.0);
                
                // Dynamic point size with quantum fluctuation
                float sizeEffect = size * hyperEffect * (1.0 + (1.0 - wProjection) * 3.0);
                gl_PointSize = sizeEffect * (1.0 + quantumEffect) * (1.0 + (1.0 - coreProximity));
                
                // Enhanced color near core with quantum shift
                vec4 coreColor = vec4(1.0, 0.2, 1.0, color.a);
                vec4 quantumColor = vec4(0.2, 0.8, 1.0, color.a);
                vColor = mix(mix(color, coreColor, 1.0 - coreProximity), quantumColor, abs(quantumEffect));
                vSize = sizeEffect;
                vDist = dist;
            }
        `;

        const fragmentShaderSource = `
            precision mediump float;
            
            varying vec4 vColor;
            varying float vSize;
            varying float vDist;
            uniform float time;
            
            void main() {
                vec2 coord = gl_PointCoord * 2.0 - 1.0;
                float r = length(coord);
                if (r > 1.0) discard;
                
                // Enhanced quantum glow
                float glow = exp(-r * r * 1.5);
                float edge = smoothstep(0.8, 0.2, r);
                
                // Core resonance effect
                float pulse = sin(vDist * 20.0 - time * 0.002) * 0.5 + 0.5;
                vec4 finalColor = mix(vColor, vec4(1.0, 0.5, 1.0, vColor.a), pulse * (1.0 - r));
                
                gl_FragColor = vec4(finalColor.rgb, finalColor.a * (glow + edge * 0.5));
            }
        `;

        // Create shader program
        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, vertexShaderSource);
        gl.compileShader(vertexShader);
        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
            console.error('Vertex shader compile error:', gl.getShaderInfoLog(vertexShader));
        }

        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, fragmentShaderSource);
        gl.compileShader(fragmentShader);
        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
            console.error('Fragment shader compile error:', gl.getShaderInfoLog(fragmentShader));
        }

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program link error:', gl.getProgramInfoLog(program));
            throw new Error('Failed to initialize shaders');
        }
        gl.useProgram(program);

        // Add time uniform location
        const timeLocation = gl.getUniformLocation(program, 'time');
        
        // Generate 4D points with enhanced density
        function generatePoints(size) {
            const points = [];
            const colors = [];
            const sizes = [];
            
            for (let w = -size; w <= size; w++) {
                for (let x = -size; x <= size; x++) {
                    for (let y = -size; y <= size; y++) {
                        for (let z = -size; z <= size; z++) {
                            if (Math.random() < 0.1) {  // Adjusted density
                                points.push(w/size, x/size, y/size, z/size);
                                
                                // Enhanced color scheme
                                const dist = Math.sqrt(w*w + x*x + y*y + z*z) / size;
                                const hue = (dist * 360) % 360;
                                const rgb = hslToRgb(hue/360, 0.8, 0.5);
                                colors.push(...rgb, 0.8);
                                
                                // Dynamic point sizes
                                sizes.push(Math.max(2, (1 - dist) * 5));
                            }
                        }
                    }
                }
            }
            return { points, colors, sizes };
        }

        function hslToRgb(h, s, l) {
            let r, g, b;
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };

                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return [r, g, b];
        }

        // Set up initial state
        const navigatorState = {
            isDragging: false,
            targetVector: { x: 100, y: 100 },
            pinchStart: null,
            lastPinchDistance: 0,
            wProjection: 1.0,
            hyperCurvature: 1.0,
            lastFrameTime: 0,
            position: { x: 0, y: 0, z: 0, w: 0 },
            velocity: { x: 0, y: 0, z: 0, w: 0 },
            speed: 0.01,
            focalLength: 1.0,
            zoomSpeed: 0.001  // Reduced zoom speed
        };

        const baseFreqs = {
            wx: 0, wy: 0, wz: 0,
            xy: 0, xz: 0, yz: 0
        };

        const freqs = { ...baseFreqs };

        // Add keyboard controls
        const keys = new Set();
        
        document.addEventListener('keydown', (e) => {
            keys.add(e.key.toLowerCase());
            
            // Reset position with R key
            if (e.key.toLowerCase() === 'r') {
                navigatorState.position = { x: 0, y: 0, z: 0, w: 0 };
                navigatorState.velocity = { x: 0, y: 0, z: 0, w: 0 };
                navigatorState.wProjection = 1.0;
                navigatorState.focalLength = 1.0;
            }
        });
        
        document.addEventListener('keyup', (e) => {
            keys.delete(e.key.toLowerCase());
        });

        function updatePosition(deltaTime) {
            // Base movement speed
            let speed = navigatorState.speed * deltaTime;
            
            // Adjust speed based on zoom level - slower when zoomed in
            speed *= Math.min(1.0, navigatorState.wProjection);
            
            // WASD for X-Z movement
            if (keys.has('w')) navigatorState.position.z -= speed;
            if (keys.has('s')) navigatorState.position.z += speed;
            if (keys.has('a')) navigatorState.position.x -= speed;
            if (keys.has('d')) navigatorState.position.x += speed;
            
            // QE for Y movement
            if (keys.has('q')) navigatorState.position.y += speed;
            if (keys.has('e')) navigatorState.position.y -= speed;
            
            // ZX for W (4th dimension) movement
            if (keys.has('z')) navigatorState.position.w -= speed;
            if (keys.has('x')) navigatorState.position.w += speed;
            
            // Shift/Ctrl for speed control
            if (keys.has('shift')) {
                navigatorState.speed = 0.03;
            } else if (keys.has('control')) {
                navigatorState.speed = 0.003; // Ultra-fine control
            } else {
                navigatorState.speed = 0.01;
            }
            
            // Space/C for zoom
            const zoomSpeed = navigatorState.zoomSpeed * deltaTime;
            if (keys.has(' ')) {
                // Exponential zoom for smoother close-ups
                navigatorState.wProjection *= (1 - zoomSpeed);
                // Allow extremely close zoom
                navigatorState.wProjection = Math.max(0.001, navigatorState.wProjection);
            }
            if (keys.has('c')) {
                navigatorState.wProjection *= (1 + zoomSpeed);
                navigatorState.wProjection = Math.min(2.5, navigatorState.wProjection);
            }
            
            // [ and ] for focal length adjustment
            if (keys.has('[')) {
                navigatorState.focalLength = Math.max(0.1, navigatorState.focalLength - speed);
            }
            if (keys.has(']')) {
                navigatorState.focalLength = Math.min(5.0, navigatorState.focalLength + speed);
            }
        }

        // Generate 4D points with enhanced density
        const gridSize = 12; // Increased grid size
        const { points, colors, sizes } = generatePoints(gridSize);

        // Create and bind buffers
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(points), gl.STATIC_DRAW);

        const colorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);

        const sizeBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sizes), gl.STATIC_DRAW);

        function render(currentTime) {
            const deltaTime = currentTime - navigatorState.lastFrameTime;
            navigatorState.lastFrameTime = currentTime;

            // Update position based on keyboard input
            updatePosition(deltaTime);

            // Update rotation frequencies
            Object.keys(freqs).forEach(key => {
                freqs[key] += baseFreqs[key];
            });

            // Clear and set up GL state
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE);

            // Pass uniforms
            gl.uniform1f(timeLocation, currentTime);
            gl.uniform1f(gl.getUniformLocation(program, 'focalLength'), navigatorState.focalLength);
            
            // Get rotation matrix and combine with position
            const rotationMatrix = get4DRotationMatrix(
                freqs.wx, freqs.wy, freqs.wz,
                freqs.xy, freqs.xz, freqs.yz
            );
            
            // Apply position translation
            const matrix = new Float32Array(rotationMatrix);
            matrix[12] = navigatorState.position.x;
            matrix[13] = navigatorState.position.y;
            matrix[14] = navigatorState.position.z;
            matrix[15] = 1.0 + navigatorState.position.w;

            // Set uniforms
            gl.uniformMatrix4fv(gl.getUniformLocation(program, 'matrix'), false, matrix);
            gl.uniform1f(gl.getUniformLocation(program, 'wProjection'), navigatorState.wProjection);
            gl.uniform1f(gl.getUniformLocation(program, 'hyperCurvature'), navigatorState.hyperCurvature);

            // Set up attributes and uniforms
            const positionLocation = gl.getAttribLocation(program, 'position');
            const colorLocation = gl.getAttribLocation(program, 'color');
            const sizeLocation = gl.getAttribLocation(program, 'size');
            
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 4, gl.FLOAT, false, 0, 0);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.enableVertexAttribArray(colorLocation);
            gl.vertexAttribPointer(colorLocation, 4, gl.FLOAT, false, 0, 0);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer);
            gl.enableVertexAttribArray(sizeLocation);
            gl.vertexAttribPointer(sizeLocation, 1, gl.FLOAT, false, 0, 0);

            // Draw points
            gl.drawArrays(gl.POINTS, 0, points.length / 4);

            requestAnimationFrame(render);
        }

        function resizeCanvas() {
            const canvas = document.getElementById('glCanvas');
            const pixelRatio = window.devicePixelRatio || 1;
            canvas.width = window.innerWidth * pixelRatio;
            canvas.height = window.innerHeight * pixelRatio;
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';
            gl.viewport(0, 0, canvas.width, canvas.height);
        }

        function initQuantumNavigator() {
            const navigator = document.getElementById('quantum-navigator');
            const vector = document.getElementById('navigator-vector');
            
            let isDragging = false;
            let startX = 0;
            let startY = 0;

            navigator.addEventListener('pointerdown', (e) => {
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                navigator.setPointerCapture(e.pointerId);
            });

            navigator.addEventListener('pointermove', (e) => {
                if (!isDragging) return;
                
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                
                baseFreqs.wx += dx * 0.001;
                baseFreqs.wy += dy * 0.001;
                
                startX = e.clientX;
                startY = e.clientY;
            });

            navigator.addEventListener('pointerup', () => {
                isDragging = false;
            });

            navigator.addEventListener('pointercancel', () => {
                isDragging = false;
            });
        }

        function handlePinchZoom(e) {
            if (e.touches.length !== 2) {
                navigatorState.pinchStart = null;
                navigatorState.lastPinchDistance = 0;
                return;
            }

            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            const distance = Math.hypot(
                touch2.clientX - touch1.clientX,
                touch2.clientY - touch1.clientY
            );

            if (!navigatorState.pinchStart) {
                navigatorState.pinchStart = distance;
                navigatorState.lastPinchDistance = distance;
                return;
            }

            const delta = distance - navigatorState.lastPinchDistance;
            navigatorState.lastPinchDistance = distance;

            // Enhanced pinch speed and range
            const pinchSpeed = 0.01; // Increased from 0.008
            const pinchDelta = delta * pinchSpeed;

            // Allow even closer zoom (0.03 instead of 0.05)
            navigatorState.wProjection = Math.max(0.03, Math.min(2.5,
                navigatorState.wProjection + pinchDelta
            ));

            // Update core proximity effects
            const coreProximity = document.querySelector('.core-proximity');
            const coreIndicator = document.querySelector('.core-indicator');
            
            if (navigatorState.wProjection < 0.2) {
                coreProximity.classList.add('active');
                coreIndicator.classList.add('visible');
                // Intensity increases as we get closer
                const intensity = (0.2 - navigatorState.wProjection) * 5;
                coreProximity.style.opacity = intensity;
            } else {
                coreProximity.classList.remove('active');
                coreIndicator.classList.remove('visible');
            }

            // Enhanced cross-dimensional effects when close to core
            const zoomFactor = Math.max(0.03, navigatorState.wProjection);
            Object.keys(baseFreqs).forEach(key => {
                if (key.includes('w')) {
                    baseFreqs[key] += pinchDelta * (0.02 / zoomFactor);
                }
            });

            // Update HUD with core proximity info
            const depthValue = document.querySelector('.manifold-info .quantum-coordinate:first-child .coordinate-value');
            depthValue.textContent = `λ=${navigatorState.wProjection.toFixed(3)}`;
            
            // Update entropy based on core proximity
            const entropyValue = document.querySelector('.manifold-info .quantum-coordinate:last-child .coordinate-value');
            const baseEntropy = 1.317;
            const proximityFactor = Math.max(1, (0.2 / navigatorState.wProjection));
            entropyValue.textContent = `${(baseEntropy * proximityFactor).toFixed(3)} qbits`;
        }

        // Add touch event listeners
        document.addEventListener('touchstart', handlePinchZoom);
        document.addEventListener('touchmove', handlePinchZoom);
        document.addEventListener('touchend', handlePinchZoom);

        // Initialize
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        initQuantumNavigator();
        requestAnimationFrame(render);

        // Add 4D rotation matrix function
        function get4DRotationMatrix(wx, wy, wz, xy, xz, yz) {
            const cwx = Math.cos(wx), swx = Math.sin(wx);
            const cwy = Math.cos(wy), swy = Math.sin(wy);
            const cwz = Math.cos(wz), swz = Math.sin(wz);
            const cxy = Math.cos(xy), sxy = Math.sin(xy);
            const cxz = Math.cos(xz), sxz = Math.sin(xz);
            const cyz = Math.cos(yz), syz = Math.sin(yz);

            // Create 4x4 rotation matrix combining all rotations
            return new Float32Array([
                cwx*cwy*cwz - swx*swy, -cwx*swz, cwx*cwy*swz + swx*swy, swx*cwy,
                swx*cwy*cwz + cwx*swy, cwx*cwz, swx*cwy*swz - cwx*swy, -cwx*cwy,
                -swy*cwz, swz, -swy*swz, cwy,
                0, 0, 0, 1
            ]);
        }
    </script>
</body>
</html>
