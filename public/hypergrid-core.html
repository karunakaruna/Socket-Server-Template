<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HyperGrid Core</title>
    <style>
        /* Original styles */
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100vw;
            height: 100vh;
        }
        
        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }
        
        #quantum-navigator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 200px;
            border: 2px solid rgba(0, 255, 255, 0.2);
            border-radius: 50%;
            cursor: crosshair;
            background: radial-gradient(circle at 50% 50%,
                rgba(255, 255, 255, 0.1),
                rgba(0, 100, 255, 0.15),
                rgba(0, 0, 0, 0.5)
            );
            box-shadow: 0 0 40px rgba(0, 100, 255, 0.2);
            z-index: 1000;
            touch-action: none;
            pointer-events: auto;
        }

        #navigator-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            pointer-events: none;
        }

        #navigator-grid::before,
        #navigator-grid::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.1);
        }

        #navigator-grid::before {
            top: 50%;
            left: 0;
            width: 100%;
            height: 1px;
            transform: translateY(-50%);
        }

        #navigator-grid::after {
            top: 0;
            left: 50%;
            width: 1px;
            height: 100%;
            transform: translateX(-50%);
        }

        #navigator-vector {
            position: absolute;
            width: 6px;
            height: 6px;
            background: rgba(0, 255, 255, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px cyan;
        }

        #quantum-hud {
            position: fixed;
            top: 20px;
            left: 20px;
            font-family: 'Courier New', monospace;
            color: rgba(0, 255, 255, 0.8);
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            pointer-events: none;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(0, 255, 255, 0.2);
            backdrop-filter: blur(5px);
        }

        .quantum-coordinate {
            margin: 5px 0;
            display: flex;
            align-items: center;
        }

        .coordinate-label {
            width: 120px;
            opacity: 0.7;
        }

        .coordinate-value {
            font-family: 'Consolas', monospace;
            color: #0ff;
        }

        .manifold-info {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid rgba(0, 255, 255, 0.2);
        }

        .quantum-bar {
            width: 100px;
            height: 4px;
            background: rgba(0, 255, 255, 0.2);
            margin-left: 10px;
            border-radius: 2px;
            overflow: hidden;
        }

        .quantum-bar-fill {
            height: 100%;
            background: rgba(0, 255, 255, 0.8);
            transition: width 0.3s ease;
        }

        /* New Core Proximity Effect */
        .core-proximity {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100px;
            height: 100px;
            background: radial-gradient(circle at center,
                rgba(255, 0, 255, 0.2) 0%,
                rgba(0, 255, 255, 0.1) 50%,
                transparent 100%
            );
            border-radius: 50%;
            pointer-events: none;
            z-index: 999;
            opacity: 0;
            transition: all 0.3s ease;
        }

        .core-proximity.active {
            opacity: 1;
            width: 200px;
            height: 200px;
        }

        .core-indicator {
            position: fixed;
            top: 10px;
            right: 10px;
            font-family: 'Courier New', monospace;
            color: #ff00ff;
            text-shadow: 0 0 10px rgba(255, 0, 255, 0.5);
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
            border: 1px solid rgba(255, 0, 255, 0.3);
            display: none;
        }

        .core-indicator.visible {
            display: block;
        }

        /* Control panel styles */
        .control-panel {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            z-index: 1000;
        }

        .control-btn {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid rgba(0, 255, 255, 0.3);
            color: #0ff;
            padding: 8px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            transition: all 0.3s ease;
            min-width: 80px;
            text-align: center;
        }

        .control-btn:hover {
            background: rgba(0, 255, 255, 0.2);
            border-color: rgba(0, 255, 255, 0.5);
        }

        .control-btn.active {
            background: rgba(0, 255, 255, 0.3);
            border-color: rgba(0, 255, 255, 0.8);
        }

        /* Manifold visualization */
        .manifold-vis {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 300px;
            height: 200px;
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 15px;
            padding: 15px;
            backdrop-filter: blur(10px);
            display: none;
            z-index: 1000;
            transition: all 0.3s ease;
        }

        .manifold-stats {
            position: absolute;
            bottom: 10px;
            left: 15px;
            right: 15px;
            color: #0ff;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            display: flex;
            justify-content: space-between;
            opacity: 0.8;
        }

        .manifold-stats span {
            color: #f0f;
        }

        .manifold-axis-label {
            position: absolute;
            color: rgba(0, 255, 255, 0.6);
            font-family: 'Courier New', monospace;
            font-size: 10px;
        }

        .manifold-axis-label.x {
            bottom: 25px;
            left: 50%;
            transform: translateX(-50%);
        }

        .manifold-axis-label.y {
            top: 50%;
            left: 5px;
            transform: rotate(-90deg) translateX(-50%);
            transform-origin: left center;
        }

        .manifold-vis.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .manifold-canvas {
            width: 100%;
            height: 100%;
            border-radius: 10px;
        }

        .manifold-label {
            position: absolute;
            top: -20px;
            left: 15px;
            color: #0ff;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            opacity: 0.8;
        }

        /* Core visualization styles */
        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }
        
        .stats {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #0ff;
            font-family: 'Courier New', monospace;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 10px;
            z-index: 1;
        }

        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 1;
        }

        button {
            background: rgba(0, 0, 0, 0.7);
            color: #0ff;
            border: 1px solid rgba(0, 255, 255, 0.3);
            padding: 8px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            transition: all 0.3s ease;
        }

        button:hover {
            background: rgba(0, 255, 255, 0.1);
        }

        button.active {
            background: rgba(0, 255, 255, 0.2);
        }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    <div id="quantum-navigator">
        <div id="navigator-grid"></div>
        <div id="navigator-vector"></div>
    </div>
    <div id="quantum-hud">
        <div class="quantum-coordinate">
            <span class="coordinate-label">Phase:</span>
            <span class="coordinate-value">0.00Ï€</span>
        </div>
        <div class="quantum-coordinate">
            <span class="coordinate-label">Spin:</span>
            <span class="coordinate-value">â†‘</span>
        </div>
        <div class="quantum-coordinate">
            <span class="coordinate-label">Entangled:</span>
            <span class="coordinate-value">No</span>
        </div>
        <div class="manifold-info">
            <div class="quantum-coordinate">
                <span class="coordinate-label">Manifold Depth:</span>
                <span class="coordinate-value">Î»=0.800</span>
            </div>
            <div class="quantum-coordinate">
                <span class="coordinate-label">Curvature:</span>
                <span class="coordinate-value">Îº=1.400</span>
            </div>
            <div class="quantum-coordinate">
                <span class="coordinate-label">Q-Entropy:</span>
                <span class="coordinate-value">1.317 qbits</span>
            </div>
        </div>
    </div>
    <div class="core-proximity"></div>
    <div class="core-indicator">CORE PROXIMITY ALERT v2.1</div>

    <!-- Control Panel -->
    <div class="control-panel">
        <div class="control-btn" id="homeBtn">HOME</div>
        <div class="control-btn" id="stopBtn">STOP</div>
        <div class="control-btn" id="manifoldBtn">MANIFOLD</div>
    </div>

    <!-- Manifold Visualization -->
    <div class="manifold-vis">
        <div class="manifold-label">MANIFOLD TOPOLOGY</div>
        <canvas id="manifoldCanvas" class="manifold-canvas"></canvas>
        <div class="manifold-axis-label x">SPATIAL POSITION</div>
        <div class="manifold-axis-label y">CURVATURE</div>
        <div class="manifold-stats">
            <div>Î»=<span id="manifoldDepth">0.000</span></div>
            <div>Îº=<span id="manifoldCurv">0.000</span></div>
            <div>âˆ‡=<span id="manifoldGrad">0.000</span></div>
        </div>
    </div>

    <script>
        // Global state and variables
        const navigatorState = {
            spinning: true,
            showManifold: false,
            phase: 0,
            hyperCurvature: 1.0,
            wProjection: 1.0
        };
        
        let diveDepth = 0;
        let playerEnergy = 0;
        let dimensionalPhase = 0;
        let mouseX, mouseY;
        let mousePressed = false;
        const particles = [];
        const psiBoids = [];
        const keyState = new Set();

        // Track dimensional information and echoes
        let dimensionalEchoes = [];
        let discoveredPatterns = new Set();

        // Canvas setup
        const coreCanvas = document.createElement('canvas');
        coreCanvas.style.position = 'absolute';
        coreCanvas.style.top = '0';
        coreCanvas.style.left = '0';
        coreCanvas.style.width = '100%';
        coreCanvas.style.height = '100%';
        document.body.appendChild(coreCanvas);
        
        const coreCtx = coreCanvas.getContext('2d');

        // Initialize canvas size
        function initCanvas() {
            coreCanvas.width = window.innerWidth;
            coreCanvas.height = window.innerHeight;
            mouseX = coreCanvas.width / 2;
            mouseY = coreCanvas.height / 2;
            
            // Initialize psi-boids
            psiBoids.length = 0;
            const NUM_BOIDS = 500; // Increased from original
            for (let i = 0; i < NUM_BOIDS; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 400;
                psiBoids.push(new PsiBoid(
                    coreCanvas.width/2 + Math.cos(angle) * radius,
                    coreCanvas.height/2 + Math.sin(angle) * radius,
                    (Math.random() - 0.5) * 200
                ));
            }
        }

        // Event listeners
        window.addEventListener('resize', initCanvas);
        window.addEventListener('keydown', e => keyState.add(e.key.toLowerCase()));
        window.addEventListener('keyup', e => keyState.delete(e.key.toLowerCase()));
        coreCanvas.addEventListener('mousemove', e => {
            const rect = coreCanvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });
        coreCanvas.addEventListener('mousedown', () => mousePressed = true);
        coreCanvas.addEventListener('mouseup', () => mousePressed = false);

        // PsiBoid class definition
        class PsiBoid {
            constructor(x, y, z) {
                this.x = x;
                this.y = y;
                this.z = z || 0;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.vz = (Math.random() - 0.5) * 2;
                this.quantum = Math.random();
                this.phase = Math.random() * Math.PI * 2;
                this.energy = 0;
                this.dimension = Math.random() * 4;
                this.purpose = Math.floor(Math.random() * 4); // Different types of quantum fish
                this.pathPhase = Math.random() * Math.PI * 2;
                this.discoveredInfo = new Set();
                this.searchPhase = 0;
                this.lastEchoTime = 0;
            }

            update(boids, time) {
                // Energy decay
                this.energy *= 0.98;
                
                // Quantum state evolution
                this.quantum = (this.quantum + Math.sin(time + this.phase) * 0.1 + this.energy * 0.2) % 1;
                
                // Dimensional drift
                this.dimension = (this.dimension + Math.sin(time * 0.5 + this.phase) * 0.02) % 4;
                
                // Calculate center of nearby boids
                let cx = 0, cy = 0, cz = 0;
                let count = 0;
                const neighborRadius = 50 + this.energy * 30;
                
                boids.forEach(other => {
                    if (other === this) return;
                    
                    const dx = other.x - this.x;
                    const dy = other.y - this.y;
                    const dz = other.z - this.z;
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    
                    if (dist < neighborRadius && dist > 0) {
                        cx += other.x;
                        cy += other.y;
                        cz += other.z;
                        count++;
                        
                        // Energy transfer
                        if (other.energy > this.energy) {
                            this.energy += (other.energy - this.energy) * 0.1;
                        }
                        
                        // Quantum entanglement
                        if (Math.random() < 0.1 + this.energy * 0.2) {
                            this.quantum = (this.quantum + other.quantum) / 2;
                            this.dimension = (this.dimension + other.dimension) / 2;
                        }
                        
                        // Separation
                        const repel = 1 - dist/neighborRadius;
                        this.vx -= dx * repel * 0.01;
                        this.vy -= dy * repel * 0.01;
                        this.vz -= dz * repel * 0.01;
                    }
                });
                
                // Core interaction
                const centerX = coreCanvas.width/2;
                const centerY = coreCanvas.height/2;
                const dx = centerX - this.x;
                const dy = centerY - this.y;
                const distToCore = Math.sqrt(dx*dx + dy*dy);
                
                // Purpose-specific behavior
                switch(this.purpose) {
                    case 0: // Dimensional Pathfinders
                        this.pathPhase += 0.02 + this.energy * 0.03;
                        const radius = 200 + Math.sin(this.pathPhase) * 100;
                        const targetX = centerX + Math.cos(this.pathPhase) * radius;
                        const targetY = centerY + Math.sin(this.pathPhase) * radius;
                        this.vx += (targetX - this.x) * 0.001;
                        this.vy += (targetY - this.y) * 0.001;
                        break;
                        
                    case 1: // Core Dancers
                        if (distToCore > 100) {
                            this.vx += dx * 0.0001;
                            this.vy += dy * 0.0001;
                        }
                        break;
                        
                    case 2: // Energy Weavers
                        if (this.energy > 0.5) {
                            this.pathPhase += 0.05;
                            const radius = 150 + Math.sin(this.pathPhase) * 50;
                            const targetX = centerX + Math.cos(this.pathPhase) * radius;
                            const targetY = centerY + Math.sin(this.pathPhase) * radius;
                            this.vx += (targetX - this.x) * 0.002;
                            this.vy += (targetY - this.y) * 0.002;
                        }
                        break;
                        
                    case 3: // Quantum Guides
                        const playerDist = Math.sqrt(
                            (mouseX - this.x) * (mouseX - this.x) + 
                            (mouseY - this.y) * (mouseY - this.y)
                        );
                        if (diveDepth > 0.5 && playerDist < 200) {
                            this.vx += (mouseX - this.x) * 0.001;
                            this.vy += (mouseY - this.y) * 0.001;
                        }
                        break;
                }
                
                // Information gathering behavior
                if (this.energy > 0.3) {
                    this.searchPhase += 0.05 + this.energy * 0.05;
                    
                    // Search for dimensional patterns
                    if (time - this.lastEchoTime > 2) {
                        const pattern = this.detectPattern();
                        if (pattern && !discoveredPatterns.has(pattern)) {
                            discoveredPatterns.add(pattern);
                            dimensionalEchoes.push(new DimensionalEcho(this.x, this.y, pattern));
                            this.lastEchoTime = time;
                        }
                    }
                }
                
                // Update position
                this.x += this.vx;
                this.y += this.vy;
                this.z += this.vz;
                
                // Damping
                this.vx *= 0.99;
                this.vy *= 0.99;
                this.vz *= 0.99;
                
                // Screen boundaries
                const margin = 50;
                if (this.x < margin) this.vx += 0.1;
                if (this.x > coreCanvas.width - margin) this.vx -= 0.1;
                if (this.y < margin) this.vy += 0.1;
                if (this.y > coreCanvas.height - margin) this.vy -= 0.1;
                
                // Player interaction
                const playerDist = Math.sqrt(
                    (mouseX - this.x) * (mouseX - this.x) + 
                    (mouseY - this.y) * (mouseY - this.y)
                );
                if (mousePressed && playerDist < 100) {
                    this.energy = Math.min(1, this.energy + 0.1);
                }
            }

            detectPattern() {
                const distToCore = Math.sqrt(
                    (coreCanvas.width/2 - this.x) ** 2 + 
                    (coreCanvas.height/2 - this.y) ** 2
                );
                
                // Different patterns emerge at different distances and energy levels
                if (distToCore < 100 && this.energy > 0.7) return 'vortex';
                if (distToCore > 200 && this.energy > 0.5) return 'lattice';
                if (this.quantum > 0.8) return 'wave';
                return null;
            }

            draw(ctx) {
                const size = 3 + this.energy * 5;
                const alpha = 0.5 + this.energy * 0.5;
                
                // Purpose-specific colors
                let hue;
                switch(this.purpose) {
                    case 0: hue = 180; break; // Dimensional Pathfinders: Cyan
                    case 1: hue = 300; break; // Core Dancers: Purple
                    case 2: hue = 60; break;  // Energy Weavers: Yellow
                    case 3: hue = 120; break; // Quantum Guides: Green
                }
                
                // Draw boid
                ctx.fillStyle = `hsla(${hue}, 100%, 50%, ${alpha})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                ctx.fill();
                
                // Energy trail
                if (this.energy > 0.2) {
                    const trailLength = Math.floor(10 * this.energy);
                    for (let i = 0; i < trailLength; i++) {
                        const trailAlpha = alpha * (1 - i/trailLength) * 0.5;
                        ctx.fillStyle = `hsla(${hue}, 100%, 50%, ${trailAlpha})`;
                        ctx.beginPath();
                        ctx.arc(
                            this.x - this.vx * i * 2,
                            this.y - this.vy * i * 2,
                            size * (1 - i/trailLength),
                            0, Math.PI * 2
                        );
                        ctx.fill();
                    }
                }
            }
        }

        class DimensionalEcho {
            constructor(x, y, pattern) {
                this.x = x;
                this.y = y;
                this.pattern = pattern;
                this.strength = 1.0;
                this.phase = Math.random() * Math.PI * 2;
                this.frequency = 1 + Math.random() * 2;
                this.dimension = Math.random() * 4;
            }
            
            draw(ctx, time) {
                const alpha = this.strength * 0.3;
                const size = 30 + Math.sin(time * this.frequency + this.phase) * 10;
                
                // Draw dimensional pattern
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(time * 0.5);
                
                ctx.strokeStyle = `hsla(${180 + this.dimension * 40}, 100%, 70%, ${alpha})`;
                ctx.lineWidth = 1;
                
                switch(this.pattern) {
                    case 'vortex':
                        for(let i = 0; i < 5; i++) {
                            const angle = (i / 5) * Math.PI * 2 + time;
                            const radius = size * (1 + Math.sin(angle + time));
                            ctx.beginPath();
                            ctx.arc(0, 0, radius, 0, Math.PI * 0.5);
                            ctx.stroke();
                        }
                        break;
                    case 'lattice':
                        for(let i = -2; i <= 2; i++) {
                            for(let j = -2; j <= 2; j++) {
                                ctx.beginPath();
                                ctx.arc(i * size/2, j * size/2, 2, 0, Math.PI * 2);
                                ctx.stroke();
                            }
                        }
                        break;
                    case 'wave':
                        ctx.beginPath();
                        for(let i = -size; i <= size; i += 5) {
                            const y = Math.sin(i * 0.1 + time) * 10;
                            ctx.lineTo(i, y);
                        }
                        ctx.stroke();
                        break;
                }
                
                ctx.restore();
                
                this.strength *= 0.99;
            }
        }

        // Increase particle count and add deep structures
        const DEPTH_LAYERS = 5;
        let quantumStructures = [];
        
        // Initialize quantum structures at different depths
        function initQuantumStructures() {
            for (let layer = 0; layer < DEPTH_LAYERS; layer++) {
                const depth = layer + 1;
                const structures = [];
                
                // Add geometric structures for this layer
                const numStructures = 3 + Math.floor(Math.random() * 5);
                for (let i = 0; i < numStructures; i++) {
                    structures.push({
                        type: ['tetrahedron', 'cube', 'octahedron', 'dodecahedron'][Math.floor(Math.random() * 4)],
                        x: coreCanvas.width/2 + (Math.random() - 0.5) * 300,
                        y: coreCanvas.height/2 + (Math.random() - 0.5) * 300,
                        rotation: Math.random() * Math.PI * 2,
                        size: 50 + Math.random() * 100,
                        depth: depth,
                        phase: Math.random() * Math.PI * 2,
                        frequency: 0.5 + Math.random()
                    });
                }
                quantumStructures.push(structures);
            }
        }

        // Draw a platonic solid
        function drawPlatonicSolid(ctx, type, x, y, size, rotation, alpha) {
            ctx.strokeStyle = `hsla(180, 100%, 70%, ${alpha})`;
            ctx.lineWidth = 2;
            
            switch(type) {
                case 'tetrahedron':
                    // Draw tetrahedron projection
                    ctx.beginPath();
                    for (let i = 0; i < 4; i++) {
                        const angle1 = rotation + i * Math.PI * 2/3;
                        const angle2 = rotation + ((i+1) % 3) * Math.PI * 2/3;
                        ctx.moveTo(x + Math.cos(angle1) * size, y + Math.sin(angle1) * size);
                        ctx.lineTo(x + Math.cos(angle2) * size, y + Math.sin(angle2) * size);
                        // Connect to apex
                        ctx.moveTo(x + Math.cos(angle1) * size, y + Math.sin(angle1) * size);
                        ctx.lineTo(x, y - size);
                    }
                    break;
                    
                case 'cube':
                    // Draw cube projection
                    const corners = [];
                    for (let i = 0; i < 4; i++) {
                        const angle = rotation + i * Math.PI/2;
                        corners.push({
                            x: x + Math.cos(angle) * size,
                            y: y + Math.sin(angle) * size
                        });
                    }
                    ctx.beginPath();
                    // Draw front face
                    for (let i = 0; i < 4; i++) {
                        ctx.moveTo(corners[i].x, corners[i].y);
                        ctx.lineTo(corners[(i+1)%4].x, corners[(i+1)%4].y);
                    }
                    // Draw depth lines
                    for (let i = 0; i < 4; i++) {
                        ctx.moveTo(corners[i].x, corners[i].y);
                        ctx.lineTo(corners[i].x - size/2, corners[i].y - size/2);
                    }
                    break;
                    
                default:
                    // Simpler geometric form for other types
                    ctx.beginPath();
                    const points = type === 'octahedron' ? 8 : 12;
                    for (let i = 0; i < points; i++) {
                        const angle = rotation + i * Math.PI * 2/points;
                        const radius = size * (1 + Math.sin(angle * 3) * 0.2);
                        ctx.lineTo(x + Math.cos(angle) * radius, y + Math.sin(angle) * radius);
                    }
                    ctx.closePath();
            }
            ctx.stroke();
        }

        // Diving mechanics
        function updateDiving(time) {
            // Clear previous frame
            coreCtx.clearRect(0, 0, coreCanvas.width, coreCanvas.height);
            
            // WASD/Arrow keys to swim
            const moveSpeed = 0.1 * (1 + playerEnergy);
            if (keyState.has('w') || keyState.has('arrowup')) mouseY -= moveSpeed * 5;
            if (keyState.has('s') || keyState.has('arrowdown')) mouseY += moveSpeed * 5;
            if (keyState.has('a') || keyState.has('arrowleft')) mouseX -= moveSpeed * 5;
            if (keyState.has('d') || keyState.has('arrowright')) mouseX += moveSpeed * 5;
            
            // Space to dive deeper
            if (keyState.has(' ')) {
                diveDepth += 0.02 * (1 + playerEnergy);
                dimensionalPhase += 0.01;
                
                // Dimensional shifting effect
                const shiftCount = Math.floor(10 * diveDepth);
                for (let i = 0; i < shiftCount; i++) {
                    const angle = (i / shiftCount) * Math.PI * 2;
                    const radius = 100 * (1 + diveDepth);
                    const x = mouseX + Math.cos(angle) * radius;
                    const y = mouseY + Math.sin(angle) * radius;
                    
                    trailCtx.beginPath();
                    trailCtx.moveTo(mouseX, mouseY);
                    trailCtx.lineTo(x, y);
                    const gradient = trailCtx.createLinearGradient(mouseX, mouseY, x, y);
                    gradient.addColorStop(0, `hsla(${180 + diveDepth * 60}, 100%, 50%, 0.5)`);
                    gradient.addColorStop(1, 'transparent');
                    trailCtx.strokeStyle = gradient;
                    trailCtx.lineWidth = 1;
                    trailCtx.stroke();
                }
                
                // Reveal neighboring dimensions
                if (diveDepth > 0.5) {
                    const echoCount = Math.floor(diveDepth * 10);
                    for (let i = 0; i < echoCount; i++) {
                        const angle = time + (i / echoCount) * Math.PI * 2;
                        const x = mouseX + Math.cos(angle) * 100;
                        const y = mouseY + Math.sin(angle) * 100;
                        
                        trailCtx.beginPath();
                        trailCtx.arc(x, y, 5, 0, Math.PI * 2);
                        trailCtx.fillStyle = `hsla(${180 + i * 30}, 100%, 50%, 0.3)`;
                        trailCtx.fill();
                    }
                }
            } else {
                diveDepth *= 0.99; // Slowly return unless actively diving
            }
            
            // Update player energy
            if (mousePressed) {
                playerEnergy = Math.min(1, playerEnergy + 0.01);
            } else {
                playerEnergy *= 0.99;
            }

            // Apply diving effects
            const scale = 1 + diveDepth;
            coreCtx.save();
            coreCtx.translate(coreCanvas.width/2, coreCanvas.height/2);
            coreCtx.scale(scale, scale);
            coreCtx.translate(-coreCanvas.width/2, -coreCanvas.height/2);

            // Add dimensional ripples when diving
            if (diveDepth > 0.1) {
                const rippleCount = Math.floor(10 * diveDepth);
                for (let i = 0; i < rippleCount; i++) {
                    const ripplePhase = (time + i/rippleCount) * Math.PI * 2;
                    const rippleSize = (200 + Math.sin(ripplePhase) * 100) * (1 + diveDepth);
                    const alpha = 0.1 * (1 - i/rippleCount) * Math.sin(ripplePhase);
                    
                    coreCtx.strokeStyle = `hsla(${180 + diveDepth * 40}, 100%, 50%, ${alpha})`;
                    coreCtx.lineWidth = 2;
                    coreCtx.beginPath();
                    coreCtx.arc(
                        coreCanvas.width/2, 
                        coreCanvas.height/2, 
                        rippleSize, 
                        0, Math.PI * 2
                    );
                    coreCtx.stroke();
                }
            }
            coreCtx.restore();
        }

        function drawOortCloud(timestamp) {
            const time = timestamp * 0.001;
            
            // Clear both canvases with fade effect
            trailCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            trailCtx.fillRect(0, 0, trailCanvas.width, trailCanvas.height);
            coreCtx.clearRect(0, 0, coreCanvas.width, coreCanvas.height);

            // Update and draw psi-boids
            psiBoids.forEach(boid => {
                boid.update(psiBoids, time);
                boid.draw(coreCtx);
            });

            // Draw the core with enhanced effects
            const coreGlow = coreCtx.createRadialGradient(
                coreCanvas.width/2, coreCanvas.height/2, 0,
                coreCanvas.width/2, coreCanvas.height/2, 200
            );
            coreGlow.addColorStop(0, `hsla(180, 100%, 50%, ${0.3 + Math.sin(time) * 0.1})`);
            coreGlow.addColorStop(0.5, `hsla(180, 100%, 30%, ${0.2 + diveDepth * 0.3})`);
            coreGlow.addColorStop(1, 'transparent');
            
            coreCtx.fillStyle = coreGlow;
            coreCtx.beginPath();
            coreCtx.arc(coreCanvas.width/2, coreCanvas.height/2, 200, 0, Math.PI * 2);
            coreCtx.fill();

            // Draw dimensional ripples when diving
            if (diveDepth > 0.1) {
                const rippleCount = Math.floor(20 * diveDepth);
                for (let i = 0; i < rippleCount; i++) {
                    const ripplePhase = (time + i/rippleCount) * Math.PI * 2;
                    const rippleSize = (100 + Math.sin(ripplePhase) * 30) * (1 + diveDepth);
                    const alpha = 0.2 * (1 - i/rippleCount) * Math.sin(ripplePhase);
                    
                    coreCtx.strokeStyle = `hsla(${180 + i * 20}, 100%, 50%, ${alpha})`;
                    coreCtx.lineWidth = 2;
                    coreCtx.beginPath();
                    coreCtx.arc(
                        coreCanvas.width/2, 
                        coreCanvas.height/2, 
                        rippleSize, 
                        0, Math.PI * 2
                    );
                    coreCtx.stroke();
                }
            }

            // Draw dimensional echoes with enhanced visibility
            dimensionalEchoes = dimensionalEchoes.filter(echo => echo.strength > 0.1);
            dimensionalEchoes.forEach(echo => {
                echo.draw(trailCtx, time);
                
                // Add connecting lines to nearby echoes for dimensional mapping
                dimensionalEchoes.forEach(other => {
                    const dx = echo.x - other.x;
                    const dy = echo.y - other.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 200 && echo !== other) {
                        trailCtx.beginPath();
                        trailCtx.moveTo(echo.x, echo.y);
                        trailCtx.lineTo(other.x, other.y);
                        trailCtx.strokeStyle = `hsla(${180 + echo.dimension * 30}, 100%, 70%, ${echo.strength * 0.2})`;
                        trailCtx.lineWidth = 1;
                        trailCtx.stroke();
                    }
                });
            });

            // Draw information HUD
            if (diveDepth > 0.3) {
                const patternCount = discoveredPatterns.size;
                trailCtx.font = '20px monospace';
                trailCtx.fillStyle = `hsla(180, 100%, 70%, ${0.7 + diveDepth * 0.3})`;
                trailCtx.fillText(`Dimensional Patterns: ${patternCount}`, 20, 40);
                
                if (patternCount > 0) {
                    trailCtx.font = '16px monospace';
                    let y = 70;
                    discoveredPatterns.forEach(pattern => {
                        trailCtx.fillText(`âˆ™ ${pattern} pattern detected`, 25, y);
                        y += 25;
                    });
                }
            }

            // Update diving state
            updateDiving(time);
            
            // Draw quantum structures based on dive depth
            quantumStructures.forEach((layer, layerIndex) => {
                const layerDepth = layerIndex + 1;
                if (diveDepth > layerDepth * 0.2) { // Only show structures when deep enough
                    const layerAlpha = Math.min(1, (diveDepth - layerDepth * 0.2) * 2);
                    
                    layer.forEach(structure => {
                        const wobble = Math.sin(time * structure.frequency + structure.phase) * 10;
                        drawPlatonicSolid(
                            trailCtx,
                            structure.type,
                            structure.x + wobble,
                            structure.y + wobble,
                            structure.size * (1 + Math.sin(time + structure.phase) * 0.1),
                            structure.rotation + time * 0.1,
                            layerAlpha * 0.5
                        );
                    });
                }
            });
            
            requestAnimationFrame(drawOortCloud);
        }

        // Prevent text selection while interacting
        document.body.style.userSelect = 'none';
        coreCanvas.style.zIndex = '1000'; // Ensure canvas is on top
        
        // Add motion trails
        const trailCanvas = document.createElement('canvas');
        trailCanvas.style.position = 'absolute';
        trailCanvas.style.top = '0';
        trailCanvas.style.left = '0';
        trailCanvas.style.width = '100%';
        trailCanvas.style.height = '100%';
        trailCanvas.style.zIndex = '999';
        document.body.appendChild(trailCanvas);
        const trailCtx = trailCanvas.getContext('2d');

        function resizeCanvases() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            coreCanvas.width = width;
            coreCanvas.height = height;
            trailCanvas.width = width;
            trailCanvas.height = height;
            mouseX = width / 2;
            mouseY = height / 2;
        }
        window.addEventListener('resize', resizeCanvases);
        resizeCanvases();

        // Enhanced movement perception
        let playerTrail = [];
        const maxTrailLength = 20;
        
        function updateDiving(time) {
            // Clear previous frame with fade
            trailCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            trailCtx.fillRect(0, 0, trailCanvas.width, trailCanvas.height);
            
            // WASD/Arrow keys to swim with enhanced feedback
            const moveSpeed = 0.1 * (1 + playerEnergy);
            let dx = 0, dy = 0;
            
            if (keyState.has('w') || keyState.has('arrowup')) dy -= moveSpeed * 5;
            if (keyState.has('s') || keyState.has('arrowdown')) dy += moveSpeed * 5;
            if (keyState.has('a') || keyState.has('arrowleft')) dx -= moveSpeed * 5;
            if (keyState.has('d') || keyState.has('arrowright')) dx += moveSpeed * 5;
            
            // Update player position with momentum
            mouseX += dx;
            mouseY += dy;
            
            // Add to trail
            if (dx !== 0 || dy !== 0) {
                playerTrail.push({x: mouseX, y: mouseY, energy: playerEnergy});
                if (playerTrail.length > maxTrailLength) playerTrail.shift();
            }
            
            // Draw movement trail
            if (playerTrail.length > 1) {
                trailCtx.beginPath();
                trailCtx.moveTo(playerTrail[0].x, playerTrail[0].y);
                
                for (let i = 1; i < playerTrail.length; i++) {
                    const point = playerTrail[i];
                    trailCtx.lineTo(point.x, point.y);
                }
                
                trailCtx.strokeStyle = `hsla(180, 100%, 50%, ${0.3 + playerEnergy * 0.5})`;
                trailCtx.lineWidth = 2 + playerEnergy * 3;
                trailCtx.stroke();
            }
            
            // Space to dive deeper with enhanced feedback
            if (keyState.has(' ')) {
                diveDepth += 0.02 * (1 + playerEnergy);
                dimensionalPhase += 0.01;
                
                // Add diving ripples
                const rippleCount = Math.floor(20 * diveDepth);
                for (let i = 0; i < rippleCount; i++) {
                    const ripplePhase = (time + i/rippleCount) * Math.PI * 2;
                    const rippleSize = (100 + Math.sin(ripplePhase) * 30) * (1 + diveDepth);
                    const alpha = 0.2 * (1 - i/rippleCount) * Math.sin(ripplePhase);
                    
                    trailCtx.strokeStyle = `hsla(${180 + diveDepth * 60}, 100%, 50%, ${alpha})`;
                    trailCtx.lineWidth = 2;
                    trailCtx.beginPath();
                    trailCtx.arc(mouseX, mouseY, rippleSize, 0, Math.PI * 2);
                    trailCtx.stroke();
                }
            } else {
                diveDepth *= 0.99;
            }
            
            // Update player energy with visual feedback
            if (mousePressed) {
                playerEnergy = Math.min(1, playerEnergy + 0.01);
                
                // Energy gathering effect
                trailCtx.beginPath();
                trailCtx.arc(mouseX, mouseY, 20 + playerEnergy * 20, 0, Math.PI * 2);
                trailCtx.strokeStyle = `hsla(60, 100%, 50%, ${0.3 + playerEnergy * 0.5})`;
                trailCtx.lineWidth = 2;
                trailCtx.stroke();
            } else {
                playerEnergy *= 0.99;
            }

            // Apply diving effects
            const scale = 1 + diveDepth;
            coreCtx.save();
            coreCtx.translate(coreCanvas.width/2, coreCanvas.height/2);
            coreCtx.scale(scale, scale);
            coreCtx.translate(-coreCanvas.width/2, -coreCanvas.height/2);
        }

        // Add instructions overlay
        const instructions = document.createElement('div');
        instructions.style.position = 'fixed';
        instructions.style.bottom = '20px';
        instructions.style.left = '20px';
        instructions.style.color = '#0ff';
        instructions.style.fontFamily = 'monospace';
        instructions.style.pointerEvents = 'none';
        instructions.innerHTML = `
            WASD/Arrows: Swim
            Space: Dive Deeper
            Click: Feed & Energize
            Follow the quantum fish...
        `;
        document.body.appendChild(instructions);

        // Initialize quantum structures
        initQuantumStructures();
        
        // Start everything
        initCanvas();
        requestAnimationFrame(drawOortCloud);
    </script>
</body>
</html>
