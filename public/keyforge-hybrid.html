<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>KeyForge Hybrid</title>
    <style>
        * {
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        body {
            margin: 0;
            padding: 0;
            background: #1a1a1a;
            overflow: hidden;
            font-family: system-ui, -apple-system, sans-serif;
            color: #fff;
            touch-action: none;
        }

        #interaction-area {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        .draggable {
            position: absolute;
            width: 120px;
            height: 120px;
            transform: translate(-50%, -50%);
            cursor: move;
            z-index: 10;
            transition: transform 0.2s ease;
            touch-action: none;
        }

        .draggable.being-dragged {
            transform: translate(-50%, -50%) scale(1.2);
            z-index: 100;
        }

        .draggable.active {
            animation: none;
        }

        .draggable.active.circle-pulse {
            animation: circle-pulse var(--pulse-rate) infinite;
        }

        .draggable.active.square-pulse {
            animation: square-pulse var(--pulse-rate) infinite;
        }

        @keyframes circle-pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.4); }
            70% { box-shadow: 0 0 0 20px rgba(255, 0, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0); }
        }

        @keyframes square-pulse {
            0% { 
                box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.4);
                border-radius: 0;
            }
            70% { 
                box-shadow: 0 0 0 20px rgba(255, 0, 0, 0);
                border-radius: 0;
            }
            100% { 
                box-shadow: 0 0 0 0 rgba(255, 0, 0, 0);
                border-radius: 0;
            }
        }

        .draggable.active.circle-pulse::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,0,0,0.2) 0%, rgba(255,0,0,0) 70%);
        }

        .draggable.active.square-pulse::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 0;
            background: radial-gradient(circle, rgba(255,0,0,0.2) 0%, rgba(255,0,0,0) 70%);
        }

        .interaction-point {
            border: 4px solid rgba(0, 255, 0, 0.8);
            border-radius: 50%;
            mix-blend-mode: plus-lighter;
            pointer-events: none;
            touch-action: none;
        }

        .interaction-point::after {
            content: '';
            position: absolute;
            width: 12px;
            height: 12px;
            background: rgba(0, 255, 0, 0.8);
            border-radius: 50%;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }

        .hold-indicator {
            position: absolute;
            border: 4px solid rgba(255, 0, 0, 0.8);
            border-radius: 50%;
            width: 120px;
            height: 120px;
            animation: pulse 1s infinite;
            mix-blend-mode: plus-lighter;
            pointer-events: none;
        }

        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 0.8; }
            100% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; }
        }

        #debug-console {
            position: fixed;
            right: 20px;
            top: 20px;
            width: 400px;
            max-height: calc(100vh - 40px);
            background: rgba(45, 45, 45, 0.4);
            border-radius: 8px;
            overflow-y: auto;
            font-family: monospace;
            padding: 10px;
            pointer-events: none;
            mix-blend-mode: plus-lighter;
            font-size: 14px;
            z-index: 1000;
        }

        .debug-entry {
            margin: 5px 0;
            padding: 5px;
            border-left: 3px solid rgba(102, 102, 102, 0.8);
            color: rgba(255, 255, 255, 0.9);
        }

        .debug-entry.interaction-start { border-left-color: rgba(76, 175, 80, 0.8); }
        .debug-entry.interaction-move { border-left-color: rgba(33, 150, 243, 0.8); }
        .debug-entry.interaction-end { border-left-color: rgba(244, 67, 54, 0.8); }
        .debug-entry.hold { border-left-color: rgba(255, 152, 0, 0.8); }
        .debug-entry.state-change { border-left-color: rgba(255, 0, 0, 0.8); }
        .debug-entry.pulse-rate-change { border-left-color: rgba(0, 255, 0, 0.8); }
        .debug-entry.shape-change { border-left-color: rgba(0, 0, 255, 0.8); }

        .create-menu {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            z-index: 1000;
            cursor: pointer;
            touch-action: none;
        }

        .menu-option {
            position: absolute;
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.3s ease;
            opacity: 0;
            pointer-events: none;
            transform: translate(-50%, -50%) scale(0.5);
            cursor: pointer;
        }

        .menu-option.active {
            opacity: 1;
            pointer-events: auto;
            transform: translate(-50%, -50%) scale(1);
        }

        .menu-option.selected {
            background: rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%) scale(1.2);
        }

        .metadata {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            white-space: pre;
            z-index: 1000;
            top: -40px;
            left: 50%;
            transform: translateX(-50%);
        }

        @media (hover: hover) {
            .draggable:hover .metadata {
                opacity: 1;
            }
        }

        @media (max-width: 768px) {
            #debug-console {
                width: calc(100vw - 40px);
                font-size: 12px;
            }
        }

        /* Add styles for context menu */
        .context-menu {
            position: absolute;
            background: rgba(30, 30, 30, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 8px 0;
            min-width: 200px;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            opacity: 0;
            transform: scale(0.95);
            transition: all 0.2s ease;
            pointer-events: none;
        }

        .context-menu.active {
            opacity: 1;
            transform: scale(1);
            pointer-events: auto;
        }

        .context-menu-item {
            padding: 8px 16px;
            color: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.2s ease;
        }

        .context-menu-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .context-menu-separator {
            height: 1px;
            background: rgba(255, 255, 255, 0.1);
            margin: 4px 0;
        }

        .context-menu-item.active {
            background: rgba(255, 255, 255, 0.2);
        }

        .pulse-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: rgba(255, 0, 0, 0.5);
            display: inline-block;
            margin-right: 8px;
        }

        .pulse-indicator.active {
            animation: indicator-pulse 1s infinite;
        }

        @keyframes indicator-pulse {
            0% { opacity: 1; }
            50% { opacity: 0.3; }
            100% { opacity: 1; }
        }
    </style>
</head>
<body>
    <div id="interaction-area"></div>
    <div id="debug-console"></div>
    <div id="create-menu" class="create-menu">+</div>

    <script>
        const interactionArea = document.getElementById('interaction-area');
        const debugConsole = document.getElementById('debug-console');
        const activePoints = new Map();
        const holdTimers = new Map();
        const HOLD_THRESHOLD = 500; // ms
        let activeDraggable = null;
        let dragStartTime = 0;
        const DRAG_THRESHOLD = 150; // ms
        let objectCounter = 0;
        let menuActive = false;
        let menuInteractionId = null;
        let selectedOption = null;
        let isTouchDevice = false;
        let holdStartPosition = null;
        let lastTapTime = 0;
        let isHolding = false;
        const DOUBLE_TAP_THRESHOLD = 300; // ms

        // Detect touch capability
        window.addEventListener('touchstart', function onFirstTouch() {
            isTouchDevice = true;
            window.removeEventListener('touchstart', onFirstTouch);
        });

        function addDebugEntry(type, data) {
            const entry = document.createElement('div');
            entry.className = `debug-entry ${type}`;
            entry.textContent = `${type}: ${JSON.stringify(data)}`;
            debugConsole.appendChild(entry);
            debugConsole.scrollTop = debugConsole.scrollHeight;
            
            if (debugConsole.childNodes.length > 50) {
                debugConsole.removeChild(debugConsole.firstChild);
            }
        }

        function createObject(emoji) {
            const obj = document.createElement('div');
            obj.className = 'draggable';
            obj.dataset.type = 'object';
            obj.dataset.id = `obj-${++objectCounter}`;
            obj.dataset.state = 'inactive';
            obj.dataset.pulseRate = '1s';
            obj.dataset.pulseShape = Math.random() < 0.5 ? 'circle' : 'square';
            obj.dataset.primaryPulse = 'inactive';
            obj.dataset.secondaryPulse = 'inactive';
            obj.style.setProperty('--pulse-rate', obj.dataset.pulseRate);
            obj.style.left = `${window.innerWidth / 2}px`;
            obj.style.top = `${window.innerHeight / 2}px`;
            obj.innerHTML = `
                <div style="font-size: 48px; text-align: center; line-height: 120px;">${emoji}</div>
                <div class="metadata">ID: ${obj.dataset.id}
Type: ${emoji}
Primary Pulse: ${obj.dataset.primaryPulse}
Secondary Pulse: ${obj.dataset.secondaryPulse}
Shape: ${obj.dataset.pulseShape}
Rate: ${obj.dataset.pulseRate}</div>
            `;
            interactionArea.appendChild(obj);
            return obj;
        }

        function createContextMenu(obj, x, y) {
            // Remove any existing context menu
            const existingMenu = document.querySelector('.context-menu');
            if (existingMenu) existingMenu.remove();

            const menu = document.createElement('div');
            menu.className = 'context-menu';
            menu.innerHTML = `
                <div class="context-menu-item ${obj.dataset.primaryPulse === 'active' ? 'active' : ''}" data-action="toggle-primary">
                    <span class="pulse-indicator ${obj.dataset.primaryPulse === 'active' ? 'active' : ''}"></span>
                    Primary Pulse
                </div>
                <div class="context-menu-item ${obj.dataset.secondaryPulse === 'active' ? 'active' : ''}" data-action="toggle-secondary">
                    <span class="pulse-indicator ${obj.dataset.secondaryPulse === 'active' ? 'active' : ''}"></span>
                    Secondary Pulse
                </div>
                <div class="context-menu-separator"></div>
                <div class="context-menu-item" data-action="toggle-shape">
                    <span>üîÑ</span> Toggle Shape (${obj.dataset.pulseShape})
                </div>
                <div class="context-menu-item" data-action="adjust-rate">
                    <span>‚ö°</span> Pulse Rate: ${obj.dataset.pulseRate}
                </div>
                <div class="context-menu-separator"></div>
                <div class="context-menu-item" data-action="info">
                    <span>‚ÑπÔ∏è</span> Node Information
                </div>
            `;

            // Position menu
            menu.style.left = `${x}px`;
            menu.style.top = `${y}px`;

            // Ensure menu stays within viewport
            document.body.appendChild(menu);
            const menuRect = menu.getBoundingClientRect();
            if (menuRect.right > window.innerWidth) {
                menu.style.left = `${x - menuRect.width}px`;
            }
            if (menuRect.bottom > window.innerHeight) {
                menu.style.top = `${y - menuRect.height}px`;
            }

            // Add event listeners
            menu.addEventListener('click', (e) => {
                const item = e.target.closest('.context-menu-item');
                if (!item) return;

                const action = item.dataset.action;
                switch (action) {
                    case 'toggle-primary':
                        togglePulse(obj, 'primary');
                        break;
                    case 'toggle-secondary':
                        togglePulse(obj, 'secondary');
                        break;
                    case 'toggle-shape':
                        togglePulseShape(obj);
                        break;
                    case 'adjust-rate':
                        // Show rate adjustment UI
                        break;
                    case 'info':
                        showNodeInfo(obj);
                        break;
                }
                updateContextMenu(obj);
            });

            // Show menu with animation
            requestAnimationFrame(() => menu.classList.add('active'));
        }

        function togglePulse(obj, pulseType) {
            const pulseKey = `${pulseType}Pulse`;
            const currentState = obj.dataset[pulseKey];
            const newState = currentState === 'active' ? 'inactive' : 'active';
            obj.dataset[pulseKey] = newState;

            // Update metadata
            const metadata = obj.querySelector('.metadata');
            const metadataText = metadata.textContent.split('\n');
            const index = pulseType === 'primary' ? 2 : 3;
            metadataText[index] = `${pulseType.charAt(0).toUpperCase() + pulseType.slice(1)} Pulse: ${newState}`;
            metadata.textContent = metadataText.join('\n');

            // Update visual state
            updatePulseVisuals(obj);

            addDebugEntry('pulse-toggle', {
                id: obj.dataset.id,
                type: pulseType,
                state: newState
            });
        }

        function updatePulseVisuals(obj) {
            // Remove all pulse classes
            obj.classList.remove('circle-pulse', 'square-pulse');

            // Add appropriate pulse class based on active pulses
            if (obj.dataset.primaryPulse === 'active' || obj.dataset.secondaryPulse === 'active') {
                obj.classList.add('active');
                obj.classList.add(`${obj.dataset.pulseShape}-pulse`);
            } else {
                obj.classList.remove('active');
            }
        }

        function showNodeInfo(obj) {
            const info = {
                id: obj.dataset.id,
                type: obj.querySelector('.metadata').textContent.split('\n')[1].split(': ')[1],
                primaryPulse: obj.dataset.primaryPulse,
                secondaryPulse: obj.dataset.secondaryPulse,
                shape: obj.dataset.pulseShape,
                rate: obj.dataset.pulseRate,
                position: {
                    x: parseInt(obj.style.left),
                    y: parseInt(obj.style.top)
                }
            };

            addDebugEntry('node-info', info);
        }

        function updateContextMenu(obj) {
            const menu = document.querySelector('.context-menu');
            if (!menu) return;

            // Update menu items to reflect current state
            const primaryItem = menu.querySelector('[data-action="toggle-primary"]');
            const secondaryItem = menu.querySelector('[data-action="toggle-secondary"]');

            primaryItem.classList.toggle('active', obj.dataset.primaryPulse === 'active');
            secondaryItem.classList.toggle('active', obj.dataset.secondaryPulse === 'active');

            primaryItem.querySelector('.pulse-indicator').classList.toggle('active', obj.dataset.primaryPulse === 'active');
            secondaryItem.querySelector('.pulse-indicator').classList.toggle('active', obj.dataset.secondaryPulse === 'active');
        }

        function cancelHoldTimer(identifier) {
            const timer = holdTimers.get(identifier);
            if (timer) {
                clearTimeout(timer);
                holdTimers.delete(identifier);
            }
            isHolding = false;
        }

        function startHoldTimer(point, target) {
            const identifier = point.identifier ?? 'mouse';
            cancelHoldTimer(identifier);
            
            const timer = setTimeout(() => {
                isHolding = true;
                createContextMenu(target, point.clientX, point.clientY);
                addDebugEntry('show-context-menu', { 
                    id: target.dataset.id,
                    x: Math.round(point.clientX),
                    y: Math.round(point.clientY)
                });
            }, HOLD_THRESHOLD);
            
            holdTimers.set(identifier, timer);
        }

        // Add document click handler to close context menu
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.context-menu') && !isHolding) {
                const menu = document.querySelector('.context-menu');
                if (menu) menu.remove();
            }
        });

        function findDraggableTarget(point) {
            const elements = document.elementsFromPoint(point.clientX, point.clientY);
            return elements.find(el => el.classList.contains('draggable'));
        }

        function createMenuOptions() {
            const emojis = ['üîµ', 'üî¥', 'üü°', 'üü¢', '‚ö´'];
            emojis.forEach((emoji, index) => {
                const option = document.createElement('div');
                option.className = 'menu-option';
                option.textContent = emoji;
                option.dataset.emoji = emoji;
                document.body.appendChild(option);
            });
        }

        function updateMenuPositions(point, initial = false) {
            const menu = document.getElementById('create-menu');
            const menuRect = menu.getBoundingClientRect();
            const menuCenter = {
                x: menuRect.left + menuRect.width / 2,
                y: menuRect.top + menuRect.height / 2
            };

            const options = document.querySelectorAll('.menu-option');
            const radius = 100;
            let newSelectedOption = null;

            options.forEach((option, index) => {
                const angle = (index / options.length) * Math.PI * 2 - Math.PI / 2;
                const x = menuCenter.x + Math.cos(angle) * radius;
                const y = menuCenter.y + Math.sin(angle) * radius;
                
                option.style.left = `${x}px`;
                option.style.top = `${y}px`;
                option.classList.add('active');

                const dx = point.clientX - x;
                const dy = point.clientY - y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < 40) {
                    option.classList.add('selected');
                    newSelectedOption = option;
                } else {
                    option.classList.remove('selected');
                }
            });

            selectedOption = newSelectedOption;
        }

        function hideMenu() {
            menuActive = false;
            menuInteractionId = null;
            selectedOption = null;
            document.querySelectorAll('.menu-option').forEach(option => {
                option.classList.remove('active', 'selected');
            });
        }

        function toggleObjectState(obj) {
            const currentState = obj.dataset.state;
            const newState = currentState === 'active' ? 'inactive' : 'active';
            obj.dataset.state = newState;
            
            // Update metadata
            const metadata = obj.querySelector('.metadata');
            const metadataText = metadata.textContent.split('\n');
            metadataText[2] = `State: ${newState}`;
            metadata.textContent = metadataText.join('\n');
            
            // Toggle active class and shape-specific pulse animation
            obj.classList.toggle('active', newState === 'active');
            if (newState === 'active') {
                obj.classList.add(`${obj.dataset.pulseShape}-pulse`);
            } else {
                obj.classList.remove('circle-pulse', 'square-pulse');
            }
            
            addDebugEntry('state-change', {
                id: obj.dataset.id,
                state: newState,
                shape: obj.dataset.pulseShape
            });
        }

        function togglePulseShape(obj) {
            const currentShape = obj.dataset.pulseShape;
            const newShape = currentShape === 'circle' ? 'square' : 'circle';
            obj.dataset.pulseShape = newShape;
            
            // Update metadata
            const metadata = obj.querySelector('.metadata');
            const metadataText = metadata.textContent.split('\n');
            metadataText[4] = `Shape: ${newShape}`;
            metadata.textContent = metadataText.join('\n');
            
            // Update animation classes if active
            if (obj.classList.contains('active')) {
                obj.classList.remove('circle-pulse', 'square-pulse');
                obj.classList.add(`${newShape}-pulse`);
            }
            
            addDebugEntry('shape-change', {
                id: obj.dataset.id,
                shape: newShape
            });
        }

        function updatePulseRate(obj, delta) {
            const currentRate = parseFloat(obj.dataset.pulseRate);
            const newRate = Math.max(0.2, Math.min(5, currentRate + delta));
            obj.dataset.pulseRate = `${newRate}s`;
            obj.style.setProperty('--pulse-rate', `${newRate}s`);
            
            // Update metadata
            const metadata = obj.querySelector('.metadata');
            const metadataText = metadata.textContent.split('\n');
            metadataText[3] = `Pulse Rate: ${newRate}s`;
            metadata.textContent = metadataText.join('\n');
            
            addDebugEntry('pulse-rate-change', {
                id: obj.dataset.id,
                rate: newRate
            });
        }

        function handleDoubleTap(obj) {
            const currentTime = Date.now();
            if (currentTime - lastTapTime < DOUBLE_TAP_THRESHOLD) {
                togglePulseShape(obj);
                lastTapTime = 0; // Reset to prevent triple-tap
            } else {
                lastTapTime = currentTime;
            }
        }

        // Touch event handlers
        document.addEventListener('touchstart', (e) => {
            e.preventDefault();
            for (const touch of e.changedTouches) {
                const menu = document.getElementById('create-menu');
                const menuRect = menu.getBoundingClientRect();
                
                if (!menuActive && 
                    touch.clientX >= menuRect.left && 
                    touch.clientX <= menuRect.right && 
                    touch.clientY >= menuRect.top && 
                    touch.clientY <= menuRect.bottom) {
                    menuActive = true;
                    menuInteractionId = touch.identifier;
                    updateMenuPositions(touch, true);
                    return;
                }
                
                if (!activeDraggable) {
                    const target = findDraggableTarget(touch);
                    if (target) {
                        activeDraggable = target;
                        menuInteractionId = touch.identifier;
                        dragStartTime = Date.now();
                        target.classList.add('being-dragged');
                        startHoldTimer(touch, target);
                        holdStartPosition = { x: touch.pageX, y: touch.pageY };
                    }
                }
            }
        });

        document.addEventListener('touchmove', (e) => {
            e.preventDefault();
            for (const touch of e.changedTouches) {
                if (menuActive && touch.identifier === menuInteractionId) {
                    updateMenuPositions(touch);
                }
                else if (activeDraggable && touch.identifier === menuInteractionId) {
                    // Cancel hold timer if dragging
                    const dx = touch.pageX - holdStartPosition.x;
                    const dy = touch.pageY - holdStartPosition.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 10) { // Small threshold to prevent accidental cancellation
                        cancelHoldTimer(touch.identifier);
                    }
                    
                    if (!isHolding) {
                        activeDraggable.style.left = `${touch.pageX}px`;
                        activeDraggable.style.top = `${touch.pageY}px`;
                    }
                }
            }
        });

        document.addEventListener('touchend', (e) => {
            e.preventDefault();
            for (const touch of e.changedTouches) {
                if (touch.identifier === menuInteractionId) {
                    cancelHoldTimer(touch.identifier);
                    
                    if (menuActive) {
                        if (selectedOption) {
                            const emoji = selectedOption.dataset.emoji;
                            createObject(emoji);
                        }
                        hideMenu();
                    } else if (activeDraggable) {
                        const dragDuration = Date.now() - dragStartTime;
                        activeDraggable.classList.remove('being-dragged');
                        
                        if (!isHolding && dragDuration < DRAG_THRESHOLD) {
                            toggleObjectState(activeDraggable);
                        }
                        
                        activeDraggable = null;
                        menuInteractionId = null;
                    }
                }
            }
        });

        // Mouse event handlers
        document.addEventListener('mousedown', (e) => {
            if (isTouchDevice) return;

            const menu = document.getElementById('create-menu');
            const menuRect = menu.getBoundingClientRect();
            
            if (!menuActive && 
                e.clientX >= menuRect.left && 
                e.clientX <= menuRect.right && 
                e.clientY >= menuRect.top && 
                e.clientY <= menuRect.bottom) {
                menuActive = true;
                menuInteractionId = 'mouse';
                updateMenuPositions(e, true);
                return;
            }
            
            if (!activeDraggable) {
                const target = findDraggableTarget(e);
                if (target) {
                    activeDraggable = target;
                    menuInteractionId = 'mouse';
                    dragStartTime = Date.now();
                    target.classList.add('being-dragged');
                    startHoldTimer(e, target);
                    holdStartPosition = { x: e.pageX, y: e.pageY };
                }
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (isTouchDevice) return;

            if (menuActive) {
                updateMenuPositions(e);
            }
            else if (activeDraggable) {
                // Cancel hold timer if dragging
                const dx = e.pageX - holdStartPosition.x;
                const dy = e.pageY - holdStartPosition.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 10) { // Small threshold to prevent accidental cancellation
                    cancelHoldTimer('mouse');
                }
                
                if (!isHolding) {
                    activeDraggable.style.left = `${e.pageX}px`;
                    activeDraggable.style.top = `${e.pageY}px`;
                }
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (isTouchDevice) return;

            cancelHoldTimer('mouse');
            
            if (menuActive) {
                if (selectedOption) {
                    const emoji = selectedOption.dataset.emoji;
                    createObject(emoji);
                }
                hideMenu();
            } else if (activeDraggable) {
                const dragDuration = Date.now() - dragStartTime;
                activeDraggable.classList.remove('being-dragged');
                
                if (!isHolding && dragDuration < DRAG_THRESHOLD) {
                    toggleObjectState(activeDraggable);
                }
                
                activeDraggable = null;
                menuInteractionId = null;
            }
        });

        // Add wheel event for pulse rate adjustment
        document.addEventListener('wheel', (e) => {
            if (isTouchDevice) return; // Skip if touch device
            
            const target = findDraggableTarget(e);
            if (target && target.dataset.state === 'active') {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.1 : -0.1;
                updatePulseRate(target, delta);
            }
        });

        // Add double-click handler for desktop
        document.addEventListener('dblclick', (e) => {
            if (isTouchDevice) return;
            
            const target = findDraggableTarget(e);
            if (target) {
                togglePulseShape(target);
                e.preventDefault(); // Prevent text selection
            }
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            // Ensure objects stay within bounds
            document.querySelectorAll('.draggable').forEach(obj => {
                const x = parseFloat(obj.style.left);
                const y = parseFloat(obj.style.top);
                
                obj.style.left = `${Math.min(Math.max(x, 0), window.innerWidth)}px`;
                obj.style.top = `${Math.min(Math.max(y, 0), window.innerHeight)}px`;
            });
        });

        // Create menu options
        createMenuOptions();

        // Create initial objects
        createObject('üîµ');
        createObject('üî¥');
        createObject('üü°');
    </script>
</body>
</html>
