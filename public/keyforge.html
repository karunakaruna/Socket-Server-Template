<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Keyforge</title>
    <link rel="stylesheet" href="keyforge.css">
</head>
<body>
    <a href="index.html" class="nav-link">← Back to Interface</a>
    <div id="statusMessage" class="status-message"></div>

    <script>
        let activeDraggable = null;
        let lastHovered = null;
        let dragStartTime = 0;
        const DRAG_THRESHOLD = 150; // ms to consider a click vs drag

        const ENCODINGS = {
            'a': 'ascii',
            'u': 'utf8',
            'b': 'base64',
            'h': 'hex'
        };

        function showStatus(message, duration = 2000) {
            const status = document.getElementById('statusMessage');
            status.textContent = message;
            status.classList.add('show');
            setTimeout(() => status.classList.remove('show'), duration);
        }

        document.addEventListener('contextmenu', function(e) {
            e.preventDefault();
            showContextMenu(e.clientX, e.clientY);
        });

        function showContextMenu(x, y) {
            removeContextMenu();
            
            const menu = document.createElement('div');
            menu.className = 'context-menu';
            menu.innerHTML = `
                <div class="context-menu-item" onclick="createLock(${x}, ${y})">🔒 Create Lock</div>
                <div class="context-menu-item" onclick="createSoul(${x}, ${y})">✨ Create Soul</div>
                <div class="context-menu-item" onclick="createKey(${x}, ${y})">🔑 Create Key</div>
                <div class="context-menu-item" onclick="createSecret(${x}, ${y})">📜 Create Scroll</div>
            `;
            
            const menuX = x + menu.offsetWidth > window.innerWidth ? window.innerWidth - menu.offsetWidth : x;
            const menuY = y + menu.offsetHeight > window.innerHeight ? window.innerHeight - menu.offsetHeight : y;
            
            menu.style.left = menuX + 'px';
            menu.style.top = menuY + 'px';
            document.body.appendChild(menu);
        }

        function removeContextMenu() {
            const existingMenu = document.querySelector('.context-menu');
            if (existingMenu) existingMenu.remove();
        }

        document.addEventListener('click', removeContextMenu);

        function generateId() {
            return crypto.randomUUID().replace(/-/g, '').slice(0, 8);
        }

        function generateKeyString() {
            const encoding = Object.keys(ENCODINGS)[Math.floor(Math.random() * Object.keys(ENCODINGS).length)];
            return `{${encoding}${generateId()}}`;
        }

        function generateFeatherKey() {
            const length = Math.floor(Math.random() * 7) + 9; // 9-15 characters
            const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let key = 'f'; // Always starts with f
            for (let i = 1; i < length; i++) {
                key += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return key;
        }

        function encryptData(data, keyString) {
            try {
                const jsonStr = JSON.stringify(data);
                // Convert to base64 to handle special characters
                const encodedData = btoa(encodeURIComponent(jsonStr));
                const encrypted = encodedData.split('').map((char, i) => {
                    const keyChar = keyString[i % keyString.length];
                    return String.fromCharCode(char.charCodeAt(0) ^ keyChar.charCodeAt(0));
                }).join('');
                return btoa(encrypted);  // Encode final result to make it safe
            } catch (e) {
                console.error('Encryption error:', e);
                return null;
            }
        }

        function decryptData(encrypted, keyString) {
            try {
                const decoded = atob(encrypted);  // Decode the base64
                const decrypted = decoded.split('').map((char, i) => {
                    const keyChar = keyString[i % keyString.length];
                    return String.fromCharCode(char.charCodeAt(0) ^ keyChar.charCodeAt(0));
                }).join('');
                const decodedData = decodeURIComponent(atob(decrypted));
                return JSON.parse(decodedData);
            } catch (e) {
                console.error('Decryption error:', e);
                return null;
            }
        }

        function createKey(x, y) {
            const keyString = generateKeyString();
            createDraggable('🔑', keyString, x, y);
            showStatus('Key forged! 🔑');
        }

        function createChest(x, y) {
            const keyString = generateKeyString();
            const chestData = {
                id: generateId(),
                content: "Secret chest content",
                created: new Date().toISOString()
            };
            
            const encryptedData = encryptData(chestData, keyString);
            const lock = createDraggable('🔒', encryptedData, x, y);
            lock.classList.add('locked');
            lock.dataset.encrypted = 'true';
            lock.dataset.type = 'lock';
            
            // Add interaction radius
            const radius = document.createElement('div');
            radius.className = 'lock-radius';
            lock.appendChild(radius);
            
            // Create key at a distance
            const angle = Math.random() * 2 * Math.PI;
            const distance = 150 + Math.random() * 50; // Random distance between 150-200px
            const keyX = x + Math.cos(angle) * distance;
            const keyY = y + Math.sin(angle) * distance;
            
            createDraggable('🔑', keyString, keyX, keyY);
            showStatus('Chest created with matching key! 🔒');
        }

        function createSecret(x, y) {
            const featherKey = generateFeatherKey();
            const secretData = {
                id: generateId(),
                content: "Secret message",
                created: new Date().toISOString()
            };
            
            const encryptedData = encryptData(secretData, featherKey);
            const scroll = createDraggable('📜', encryptedData, x, y);
            scroll.classList.add('locked');
            scroll.dataset.encrypted = 'true';
            scroll.dataset.type = 'lock';
            scroll.dataset.secretType = 'scroll';
            
            const feather = createDraggable('🪶', featherKey, x + 70, y);
            feather.dataset.type = 'key';
            
            showStatus('Secret created with feather key! 📜🪶');
        }

        // Soul key storage
        const soulKeyStore = new Map();
        const soulRequirements = new Map();
        const activeConnections = new Set();

        function generateSoulKey() {
            const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*';
            let key = '';
            for (let i = 0; i < 64; i++) {
                key += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return key;
        }

        function createSoul(x, y) {
            const soulId = generateId();
            const soulKey1 = generateSoulKey();
            const soulKey2 = generateSoulKey();
            
            const soulData = {
                id: soulId,
                essence: "Bound spirit",
                created: new Date().toISOString(),
                requiresKeys: 2
            };
            
            soulKeyStore.set(soulId, [soulKey1, soulKey2]);
            soulRequirements.set(soulId, new Set());
            
            const encryptedData = encryptData(soulData, soulKey1 + soulKey2);
            const soul = createDraggable('✨', encryptedData, x, y);
            soul.classList.add('locked');
            soul.dataset.encrypted = 'true';
            soul.dataset.type = 'lock';
            soul.dataset.secretType = 'soul';
            soul.dataset.soulId = soulId;
            
            // Add interaction radius
            const radius = document.createElement('div');
            radius.className = 'soul-radius';
            soul.appendChild(radius);
            
            // Calculate random positions for keys
            const angle1 = Math.random() * 2 * Math.PI;
            const angle2 = angle1 + Math.PI + (Math.random() - 0.5);
            const distance = 300 + Math.random() * 100;
            
            const key1X = x + Math.cos(angle1) * distance;
            const key1Y = y + Math.sin(angle1) * distance;
            const key2X = x + Math.cos(angle2) * distance;
            const key2Y = y + Math.sin(angle2) * distance;
            
            createSoulKey(soulKey1, key1X, key1Y, soulId, 1);
            createSoulKey(soulKey2, key2X, key2Y, soulId, 2);
            
            showStatus('Soul created with two keys! ✨');
            return soul;
        }

        function checkSoulProximity(soul, key) {
            const soulRect = soul.getBoundingClientRect();
            const keyRect = key.getBoundingClientRect();
            
            const dx = (keyRect.left + keyRect.width/2) - (soulRect.left + soulRect.width/2);
            const dy = (keyRect.top + keyRect.height/2) - (soulRect.top + soulRect.height/2);
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // 200px is the radius (half of the 400px diameter)
            return distance <= 200;
        }

        function updateSoulEffects() {
            document.querySelectorAll('[data-secret-type="soul"]').forEach(soul => {
                const radius = soul.querySelector('.soul-radius');
                const soulId = soul.dataset.soulId;
                let hasNearbyKey = false;
                
                // Reset requirements for this soul
                if (soulRequirements.has(soulId)) {
                    soulRequirements.get(soulId).clear();
                }
                
                document.querySelectorAll('[data-type="soul-key"]').forEach(key => {
                    if (key.dataset.soulId === soulId && checkSoulProximity(soul, key)) {
                        hasNearbyKey = true;
                        const connection = updateSoulConnections(soul, key);
                        activeConnections.add(connection);
                        
                        // Add key to soul requirements
                        const requirements = soulRequirements.get(soulId);
                        requirements.add(parseInt(key.dataset.keyIndex));
                    }
                });
                
                if (radius) {
                    radius.classList.toggle('active', hasNearbyKey);
                }
                
                // Check for soul release or lock
                const requirements = soulRequirements.get(soulId);
                if (requirements) {
                    if (requirements.size === 2) {
                        const soulKeys = soulKeyStore.get(soulId);
                        const combinedKey = soulKeys.join('');
                        const metadata = soul.querySelector('.metadata');
                        if (!metadata.classList.contains('decrypted')) {
                            const encrypted = metadata.textContent;
                            const decrypted = decryptData(encrypted, combinedKey);
                            
                            if (decrypted) {
                                // Remove all children except metadata
                                soul.textContent = '';  // Clear all children
                                soul.appendChild(document.createTextNode('💫'));
                                
                                // Update metadata with decrypted content
                                metadata.textContent = JSON.stringify(decrypted, null, 2);
                                metadata.classList.add('decrypted');
                                soul.appendChild(metadata);
                                
                                // Add new radius
                                const radius = document.createElement('div');
                                radius.className = 'soul-radius';
                                soul.appendChild(radius);
                                showStatus('Soul released! 💫');
                            }
                        }
                    } else if (requirements.size < 2 && soul.childNodes[0]?.nodeValue === '💫') {
                        // Lock the soul when a key is removed
                        const metadata = soul.querySelector('.metadata');
                        if (metadata.classList.contains('decrypted')) {
                            soul.textContent = '';  // Clear all children
                            soul.appendChild(document.createTextNode('✨'));
                            
                            // Reset metadata to encrypted state
                            metadata.classList.remove('decrypted');
                            const soulKeys = soulKeyStore.get(soulId);
                            const combinedKey = soulKeys.join('');
                            const decrypted = JSON.parse(metadata.textContent);
                            metadata.textContent = encryptData(decrypted, combinedKey);
                            soul.appendChild(metadata);
                            
                            // Add new radius
                            const radius = document.createElement('div');
                            radius.className = 'soul-radius';
                            soul.appendChild(radius);
                            showStatus('Soul bound! ✨');
                        }
                    }
                }
            });
        }

        function createSoulKey(key, x, y, soulId, keyIndex) {
            const keyElement = createDraggable('🔮', 'soul-key', x, y);
            keyElement.dataset.type = 'soul-key';
            keyElement.dataset.soulId = soulId;
            keyElement.dataset.keyIndex = keyIndex;
            
            // Store the actual key only in memory
            soulKeyStore.set(keyElement.id, key);

            // Create main metadata showing "soul-key"
            const metadata = document.createElement('div');
            metadata.className = 'metadata';
            metadata.textContent = 'soul-key';
            metadata.style.display = 'none';
            keyElement.appendChild(metadata);

            // Create second metadata for key preview
            const keyPreview = document.createElement('div');
            keyPreview.className = 'metadata key-preview';
            keyPreview.textContent = `${key.substring(0, 11)}...`;
            keyPreview.style.display = 'none';
            keyElement.appendChild(keyPreview);

            // Add hover events for both metadata elements
            keyElement.addEventListener('mouseenter', () => {
                metadata.style.display = 'block';
                keyPreview.style.display = 'block';
                requestAnimationFrame(() => {
                    metadata.classList.add('show');
                    keyPreview.classList.add('show');
                });
            });
            keyElement.addEventListener('mouseleave', () => {
                metadata.classList.remove('show');
                keyPreview.classList.remove('show');
                metadata.style.display = 'none';
                keyPreview.style.display = 'none';
            });

            return keyElement;
        }

        function updateSoulConnections(soul, key) {
            const soulRect = soul.getBoundingClientRect();
            const keyRect = key.getBoundingClientRect();
            
            const connectionId = `${soul.dataset.soulId}-${key.id}`;
            let connection = document.getElementById(connectionId);
            
            if (!connection) {
                connection = document.createElement('div');
                connection.id = connectionId;
                connection.className = 'soul-connection';
                document.body.appendChild(connection);
            }
            
            const dx = keyRect.left - soulRect.left;
            const dy = keyRect.top - soulRect.top;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx) * 180 / Math.PI;
            
            connection.style.width = `${distance}px`;
            connection.style.left = `${soulRect.left + soulRect.width / 2}px`;
            connection.style.top = `${soulRect.top + soulRect.height / 2}px`;
            connection.style.transform = `rotate(${angle}deg)`;
            
            return connection;
        }

        // Lock key storage
        const lockKeyStore = new Map();
        const lockRequirements = new Map();

        function generateLockKey() {
            const data = {
                id: generateId(),
                essence: "Sealed secret",
                created: new Date().toISOString(),
                message: "This is a secret message! 🤫"
            };
            return data;
        }

        function createLock(x, y) {
            const lockData = generateLockKey();
            const keyString = generateKeyString();
            const encryptedData = encryptData(lockData, keyString);
            
            if (!encryptedData) {
                showStatus('Failed to create lock! ❌');
                return;
            }
            
            // Create the lock with encrypted data
            const element = createDraggable('🔒', encryptedData, x, y);
            element.dataset.type = 'lock';
            element.dataset.lockId = lockData.id;
            element.dataset.secretType = 'lock';
            
            // Add lock radius
            const radius = document.createElement('div');
            radius.className = 'soul-radius';  // Reusing soul styles
            element.appendChild(radius);
            
            // Add metadata (encrypted)
            const metadata = document.createElement('div');
            metadata.className = 'metadata';
            metadata.textContent = encryptedData;
            element.appendChild(metadata);
            
            // Create the matching key outside the radius
            const angle = Math.random() * 2 * Math.PI;
            const distance = 250; // Place key outside the radius
            const keyX = x + Math.cos(angle) * distance;
            const keyY = y + Math.sin(angle) * distance;
            createLockKey(keyX, keyY, lockData.id, keyString);
            
            showStatus('Lock manifested! 🔒');
            return element;
        }

        function createLockKey(x, y, lockId, keyString) {
            const key = createDraggable('🔑', keyString, x, y);
            key.dataset.type = 'lock-key';
            key.dataset.lockId = lockId;
            
            // Add key radius
            const radius = document.createElement('div');
            radius.className = 'soul-radius';  // Reusing soul styles
            key.appendChild(radius);
            
            // Add metadata
            const metadata = document.createElement('div');
            metadata.className = 'metadata';
            metadata.textContent = keyString;
            key.appendChild(metadata);
            
            return key;
        }

        function updateLockKeyEffects() {
            document.querySelectorAll('[data-type="lock"]').forEach(lock => {
                if (!lock.dataset.lockId) return;
                
                const lockId = lock.dataset.lockId;
                const radius = lock.querySelector('.soul-radius');
                if (!radius) return;
                
                let hasNearbyKey = false;
                let validKeyNearby = false;
                let nearbyKey = null;
                
                document.querySelectorAll('[data-type="lock-key"]').forEach(key => {
                    if (key.dataset.lockId !== lockId) return;
                    
                    if (checkLockKeyProximity(lock, key)) {
                        hasNearbyKey = true;
                        validKeyNearby = true;
                        nearbyKey = key;
                        const connection = updateLockKeyConnections(lock, key);
                        if (connection) activeConnections.add(connection);
                    }
                });
                
                radius.classList.toggle('active', hasNearbyKey);
                
                // Update lock state based on key proximity
                try {
                    const metadata = lock.querySelector('.metadata');
                    if (!metadata) return;
                    
                    if (validKeyNearby && !lock.classList.contains('decrypted')) {
                        // Decrypt the data using the nearby key
                        const keyString = nearbyKey.querySelector('.metadata').textContent;
                        const decryptedData = decryptData(metadata.textContent, keyString);
                        
                        if (decryptedData) {
                            lock.textContent = '🔓';
                            lock.classList.add('decrypted');
                            metadata.classList.add('decrypted');
                            metadata.textContent = JSON.stringify(decryptedData, null, 2);
                            lock.appendChild(metadata);
                            lock.appendChild(radius);
                            showStatus('Lock opened! 🔓');
                        }
                    } else if (!validKeyNearby && lock.classList.contains('decrypted')) {
                        // Re-encrypt the data when key moves away
                        const keyString = document.querySelector(`[data-type="lock-key"][data-lock-id="${lockId}"]`)
                            .querySelector('.metadata').textContent;
                        const data = JSON.parse(metadata.textContent);
                        const encryptedData = encryptData(data, keyString);
                        
                        if (encryptedData) {
                            lock.textContent = '🔒';
                            lock.classList.remove('decrypted');
                            metadata.classList.remove('decrypted');
                            metadata.textContent = encryptedData;
                            lock.appendChild(metadata);
                            lock.appendChild(radius);
                            showStatus('Lock secured! 🔒');
                        }
                    }
                } catch (e) {
                    console.error('Error updating lock:', e);
                }
                
                // Clean up inactive connections
                if (!hasNearbyKey) {
                    activeConnections.forEach(conn => {
                        if (conn.id.startsWith(`${lockId}-`)) {
                            conn.remove();
                            activeConnections.delete(conn);
                        }
                    });
                }
            });
        }

        function checkLockKeyProximity(lock, key) {
            const lockRect = lock.getBoundingClientRect();
            const keyRect = key.getBoundingClientRect();
            
            const dx = (keyRect.left + keyRect.width/2) - (lockRect.left + lockRect.width/2);
            const dy = (keyRect.top + keyRect.height/2) - (lockRect.top + lockRect.height/2);
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            return distance <= 200;
        }

        function updateLockKeyConnections(lock, key) {
            const lockRect = lock.getBoundingClientRect();
            const keyRect = key.getBoundingClientRect();
            
            const connectionId = `${lock.dataset.lockId}-${key.id}`;
            let connection = document.getElementById(connectionId);
            
            if (!connection) {
                connection = document.createElement('div');
                connection.id = connectionId;
                connection.className = 'soul-connection';  // Reusing soul styles
                document.body.appendChild(connection);
            }
            
            const dx = keyRect.left - lockRect.left;
            const dy = keyRect.top - lockRect.top;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx) * 180 / Math.PI;
            
            connection.style.width = `${distance}px`;
            connection.style.left = `${lockRect.left + lockRect.width / 2}px`;
            connection.style.top = `${lockRect.top + lockRect.height / 2}px`;
            connection.style.transform = `rotate(${angle}deg)`;
            
            return connection;
        }

        function checkLockProximity(lock, key) {
            const lockRect = lock.getBoundingClientRect();
            const keyRect = key.getBoundingClientRect();
            
            const dx = (keyRect.left + keyRect.width/2) - (lockRect.left + lockRect.width/2);
            const dy = (keyRect.top + keyRect.height/2) - (lockRect.top + lockRect.height/2);
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // 100px is the radius (half of the 200px diameter)
            return distance <= 100;
        }

        function updateLockConnections(lock, key) {
            const lockRect = lock.getBoundingClientRect();
            const keyRect = key.getBoundingClientRect();
            
            const connectionId = `lock-${lock.id}-${key.id}`;
            let connection = document.getElementById(connectionId);
            
            if (!connection) {
                connection = document.createElement('div');
                connection.id = connectionId;
                connection.className = 'lock-connection';
                document.body.appendChild(connection);
            }
            
            const dx = keyRect.left - lockRect.left;
            const dy = keyRect.top - lockRect.top;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx) * 180 / Math.PI;
            
            connection.style.width = `${distance}px`;
            connection.style.left = `${lockRect.left + lockRect.width / 2}px`;
            connection.style.top = `${lockRect.top + lockRect.height / 2}px`;
            connection.style.transform = `rotate(${angle}deg)`;
            
            return connection;
        }

        function updateLockEffects() {
            document.querySelectorAll('[data-type="lock"]').forEach(lock => {
                if (!lock || lock.dataset.secretType === 'soul') return; // Skip souls and invalid locks
                
                const radius = lock.querySelector('.lock-radius');
                if (!radius) return; // Skip if radius not found
                
                let hasNearbyKey = false;
                let hasValidKey = false;
                
                document.querySelectorAll('[data-type="key"]').forEach(key => {
                    if (!key || !key.querySelector('.metadata')) return; // Skip invalid keys
                    
                    if (checkLockProximity(lock, key)) {
                        hasNearbyKey = true;
                        const connection = updateLockConnections(lock, key);
                        if (connection) activeConnections.add(connection);
                        
                        const metadata = lock.querySelector('.metadata');
                        if (!metadata) return;
                        
                        try {
                            const keyString = key.querySelector('.metadata').textContent;
                            const encryptedData = metadata.textContent;
                            const decrypted = decryptData(encryptedData, keyString);
                            if (decrypted) hasValidKey = true;
                        } catch (e) {
                            console.error('Error processing lock:', e);
                        }
                    }
                });
                
                radius.classList.toggle('active', hasNearbyKey);
                
                // Update lock state based on key proximity
                if (hasValidKey && lock.classList.contains('locked')) {
                    const metadata = lock.querySelector('.metadata');
                    lock.textContent = '';  // Clear all children
                    lock.appendChild(document.createTextNode('🔓'));
                    if (metadata) lock.appendChild(metadata);
                    lock.classList.remove('locked');
                    lock.classList.add('unlock-animation');
                    showStatus('Lock opened! 🔓');
                } else if (!hasValidKey && !lock.classList.contains('locked')) {
                    const metadata = lock.querySelector('.metadata');
                    lock.textContent = '';  // Clear all children
                    lock.appendChild(document.createTextNode('🔒'));
                    if (metadata) lock.appendChild(metadata);
                    lock.classList.add('locked', 'lock-animation');
                    showStatus('Lock secured! 🔒');
                }
                
                // Clean up inactive connections
                if (!hasNearbyKey) {
                    activeConnections.forEach(conn => {
                        if (conn.id.startsWith(`lock-${lock.id}`)) {
                            conn.remove();
                            activeConnections.delete(conn);
                        }
                    });
                }
                
                // Add radius back if it was removed
                if (!lock.querySelector('.lock-radius')) {
                    const newRadius = document.createElement('div');
                    newRadius.className = 'lock-radius';
                    lock.appendChild(newRadius);
                }
            });
        }

        function createDraggable(emoji, data, x, y) {
            const element = document.createElement('div');
            element.className = 'draggable';
            
            if (emoji === '🪶') {
                const img = document.createElement('img');
                img.src = 'feather_1fab6.png';
                img.alt = 'Feather Key';
                img.draggable = false; // Prevent default drag behavior
                element.appendChild(img);
            } else {
                element.textContent = emoji;
            }
            
            element.dataset.type = emoji === '🔑' || emoji === '🪶' ? 'key' : 'lock';
            
            // Position from center
            element.style.transform = `translate(-50%, -50%)`;
            element.style.left = x + 'px';
            element.style.top = y + 'px';

            const metadata = document.createElement('div');
            metadata.className = 'metadata';
            metadata.textContent = data;
            element.appendChild(metadata);

            let isDragging = false;

            const handleMouseDown = (e) => {
                isDragging = false;
                dragStartTime = Date.now();
                activeDraggable = element;
                element.classList.add('dragging');
                element.style.zIndex = 1000;
                document.body.style.cursor = 'grabbing';
                e.preventDefault(); // Prevent text selection
            };

            const handleMouseUp = (e) => {
                const dragDuration = Date.now() - dragStartTime;
                if (dragDuration < DRAG_THRESHOLD) {
                    const metadata = element.querySelector('.metadata');
                    const isShowing = metadata.classList.contains('show');
                    toggleMetadata(element, !isShowing);
                }
                isDragging = false;
            };

            // Add event listeners to both the element and the img
            element.addEventListener('mousedown', handleMouseDown);
            element.addEventListener('mouseup', handleMouseUp);
            
            const img = element.querySelector('img');
            if (img) {
                img.addEventListener('mousedown', handleMouseDown);
                img.addEventListener('mouseup', handleMouseUp);
            }

            document.body.appendChild(element);
            return element;
        }

        function toggleMetadata(element, show) {
            const metadata = element.querySelector('.metadata');
            if (!metadata) return; // Guard against null metadata
            
            if (show) {
                metadata.style.display = 'block';
                setTimeout(() => metadata.classList.add('show'), 0);
            } else {
                metadata.classList.remove('show');
                metadata.style.display = 'none';
            }
        }

        function checkCollision(elem1, elem2) {
            if (!elem1 || !elem2) return false;
            
            const rect1 = elem1.getBoundingClientRect();
            const rect2 = elem2.getBoundingClientRect();
            
            const collision = !(rect1.right < rect2.left || 
                            rect1.left > rect2.right || 
                            rect1.bottom < rect2.top || 
                            rect1.top > rect2.bottom);
            
            if (collision) {
                // Handle soul key interactions
                if (elem1.dataset.secretType === 'soul' && elem2.dataset.type === 'soul-key' &&
                    elem1.dataset.soulId === elem2.dataset.soulId) {
                    const connection = updateSoulConnections(elem1, elem2);
                    activeConnections.add(connection);
                    
                    // Add key to soul requirements
                    const requirements = soulRequirements.get(elem1.dataset.soulId);
                    requirements.add(parseInt(elem2.dataset.keyIndex));
                    
                    // Check if all keys are present
                    if (requirements.size === 2) {
                        const soulKeys = soulKeyStore.get(elem1.dataset.soulId);
                        const combinedKey = soulKeys.join('');
                        const encrypted = elem1.querySelector('.metadata').textContent;
                        const decrypted = decryptData(encrypted, combinedKey);
                        
                        if (decrypted) {
                            elem1.textContent = '💫';
                            showStatus('Soul released! 💫');
                            
                            // Clear connections
                            activeConnections.forEach(conn => conn.remove());
                            activeConnections.clear();
                            requirements.clear();
                        }
                    }
                }
            }
            
            return collision;
        }

        document.addEventListener('mousemove', (e) => {
            if (activeDraggable) {
                isDragging = true;
                requestAnimationFrame(() => {
                    const x = e.clientX;
                    const y = e.clientY;
                    
                    const maxX = window.innerWidth;
                    const maxY = window.innerHeight;
                    const boundedX = Math.min(Math.max(0, x), maxX);
                    const boundedY = Math.min(Math.max(0, y), maxY);
                    
                    activeDraggable.style.left = boundedX + 'px';
                    activeDraggable.style.top = boundedY + 'px';

                    // Update effects
                    updateSoulEffects();
                    updateLockEffects();
                    updateLockKeyEffects();
                });
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (activeDraggable) {
                // ... existing dragging code ...

                // Remove inactive connections
                if (activeDraggable.dataset.type === 'soul-key') {
                    const soulId = activeDraggable.dataset.soulId;
                    const soul = document.querySelector(`[data-soul-id="${soulId}"]`);
                    
                    if (!checkSoulProximity(activeDraggable, soul)) {
                        const requirements = soulRequirements.get(soulId);
                        requirements.delete(parseInt(activeDraggable.dataset.keyIndex));
                        
                        // Remove connection
                        const connectionId = `${soulId}-${activeDraggable.id}`;
                        const connection = document.getElementById(connectionId);
                        if (connection) {
                            connection.remove();
                            activeConnections.delete(connection);
                        }
                    }
                }
            }
            // ... rest of mousemove handler
        });

        document.addEventListener('mouseup', (e) => {
            if (activeDraggable) {
                const dragged = activeDraggable;
                const draggedType = dragged.dataset.type;

                dragged.classList.remove('dragging');
                document.body.style.cursor = '';

                if (lastHovered && draggedType === 'key') {
                    const keyString = dragged.querySelector('.metadata').textContent;
                    const lock = lastHovered;
                    const encryptedData = lock.querySelector('.metadata').textContent;

                    if (lock.classList.contains('locked')) {
                        const decrypted = decryptData(encryptedData, keyString);
                        
                        if (decrypted) {
                            lock.classList.remove('locked');
                            lock.classList.add('unlock-animation');
                            lock.dataset.encrypted = 'false';
                            lock.querySelector('.metadata').textContent = JSON.stringify(decrypted, null, 2);
                            
                            if (lock.dataset.secretType === 'scroll') {
                                const metadata = lock.querySelector('.metadata');
                                lock.textContent = '📄';
                                lock.appendChild(metadata);
                                showStatus('Scroll unrolled! 📄');
                            } else if (lock.dataset.secretType === 'soul') {
                                const metadata = lock.querySelector('.metadata');
                                lock.textContent = '✨';
                                lock.appendChild(metadata);
                                showStatus('Soul bound! ✨');
                            } else {
                                showStatus('Lock opened! 🔓');
                            }
                        } else {
                            showStatus('Wrong key! 🚫');
                        }
                    } else {
                        const data = JSON.parse(lock.querySelector('.metadata').textContent);
                        const encrypted = encryptData(data, keyString);
                        
                        lock.classList.add('locked', 'lock-animation');
                        lock.dataset.encrypted = 'true';
                        lock.querySelector('.metadata').textContent = encrypted;
                        
                        if (lock.dataset.secretType === 'scroll') {
                            const metadata = lock.querySelector('.metadata');
                            lock.textContent = '📜';
                            lock.appendChild(metadata);
                            showStatus('Scroll sealed! 📜');
                        } else if (lock.dataset.secretType === 'soul') {
                            const metadata = lock.querySelector('.metadata');
                            lock.textContent = '✨';
                            lock.appendChild(metadata);
                            showStatus('Soul bound! ✨');
                        } else {
                            showStatus('Lock secured! 🔒');
                        }
                    }
                }

                dragged.classList.remove('key-hover');
                if (lastHovered) {
                    lastHovered.classList.remove('lock-hover');
                }
                
                dragged.style.zIndex = '';
                activeDraggable = null;
                lastHovered = null;
            }
            if (activeDraggable && activeDraggable.dataset.type === 'soul-key') {
                const soulId = activeDraggable.dataset.soulId;
                const soul = document.querySelector(`[data-soul-id="${soulId}"]`);
                
                if (!checkSoulProximity(activeDraggable, soul)) {
                    const requirements = soulRequirements.get(soulId);
                    requirements.delete(parseInt(activeDraggable.dataset.keyIndex));
                    
                    // Remove connection
                    const connectionId = `${soulId}-${activeDraggable.id}`;
                    const connection = document.getElementById(connectionId);
                    if (connection) {
                        connection.remove();
                        activeConnections.delete(connection);
                    }
                }
            }
            // ... rest of mouseup handler
        });
    </script>
</body>
</html>
