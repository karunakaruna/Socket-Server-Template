<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Œ®-WTMN Ordinal</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background-color: #1a1b26;
            color: #a9b1d6;
            overflow: hidden;
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        #shader-canvas {
            z-index: 1;
        }

        #particle-canvas {
            z-index: 2;
        }

        .content-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 3;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            user-select: none;
        }

        .psi-header {
            font-size: 120px;
            font-weight: bold;
            color: #7aa2f7;
            margin: 0 0 10px 0;
            text-shadow: 0 0 20px rgba(122, 162, 247, 0.5);
            animation: glow 2s ease-in-out infinite alternate;
            cursor: pointer;
            pointer-events: auto;
            transition: font-family 0.3s ease;
        }

        .title {
            font-size: 24px;
            font-weight: 600;
            color: #a9b1d6;
            margin: 0 0 20px 0;
            letter-spacing: 2px;
        }

        .title span {
            display: inline-block;
            transition: font-family 0.5s ease;
        }

        .server-data {
            font-size: 12px;
            color: rgba(169, 177, 214, 0.6);
            text-align: center;
            font-family: 'Courier New', monospace;
            line-height: 1.4;
            max-width: 600px;
            margin: 0;
        }

        .server-data span {
            margin: 0 8px;
        }

        #poetry {
            font-size: 24px;
            color: rgba(169, 177, 214, 0.8);
            text-align: center;
            margin: 20px 0;
            max-width: 80%;
            text-shadow: 0 0 10px rgba(169, 177, 214, 0.3);
        }

        #context {
            font-size: 18px;
            color: rgba(169, 177, 214, 0.7);
            text-align: center;
            margin: 0;
            max-width: 80%;
            text-shadow: 0 0 10px rgba(169, 177, 214, 0.3);
        }

        @keyframes glow {
            from {
                text-shadow: 0 0 20px rgba(122, 162, 247, 0.5);
            }
            to {
                text-shadow: 0 0 30px rgba(122, 162, 247, 0.8);
            }
        }

        .nav-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(26, 27, 38, 0.8);
            border: 1px solid #7aa2f7;
            color: #7aa2f7;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        .nav-toggle:hover {
            background: rgba(122, 162, 247, 0.2);
        }

        .nav-menu {
            display: block; /* Show by default for testing */
            left: 20px;
            right: auto;
            transform: translateX(0);
            position: fixed;
            top: 20px;
            z-index: 999;
            background: rgba(26, 27, 38, 0.95);
            border: 1px solid #7aa2f7;
            border-radius: 8px;
            padding: 20px;
            width: 300px;
            backdrop-filter: blur(10px);
            color: #a9b1d6;
            font-family: 'Courier New', monospace;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            cursor: move;
        }

        .nav-menu h3 {
            color: #7aa2f7;
            margin: 0 0 15px 0;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 1px solid rgba(122, 162, 247, 0.3);
            padding-bottom: 5px;
        }

        .folder-structure {
            margin-bottom: 20px;
        }

        .folder-structure ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .folder-structure li {
            padding: 3px 0 3px 20px;
            position: relative;
            font-size: 13px;
        }

        .folder-structure .folder {
            color: #e0af68;
        }

        .folder-structure .file {
            color: #9ece6a;
        }

        .folder-structure .folder::before {
            content: "üìÅ";
            position: absolute;
            left: 0;
        }

        .folder-structure .file::before {
            content: "üìÑ";
            position: absolute;
            left: 0;
        }

        .nav-menu a {
            color: inherit;
            text-decoration: none;
            transition: color 0.2s ease;
        }

        .nav-menu a:hover {
            color: #7aa2f7;
        }

        .nav-menu .routes {
            margin-bottom: 20px;
        }

        .nav-menu .route-item {
            padding: 5px 10px;
            margin: 2px 0;
            border-radius: 4px;
            transition: background 0.2s ease;
        }

        .nav-menu .route-item:hover {
            background: rgba(122, 162, 247, 0.1);
        }

        .nav-menu .description {
            font-size: 11px;
            color: rgba(169, 177, 214, 0.6);
            margin-top: 2px;
        }

        /* Custom scrollbar */
        .nav-menu::-webkit-scrollbar {
            width: 6px;
        }

        .nav-menu::-webkit-scrollbar-track {
            background: rgba(26, 27, 38, 0.5);
        }

        .nav-menu::-webkit-scrollbar-thumb {
            background: rgba(122, 162, 247, 0.3);
            border-radius: 3px;
        }

        .nav-menu::-webkit-scrollbar-thumb:hover {
            background: rgba(122, 162, 247, 0.5);
        }

        @media only screen and (max-width: 768px) {
            .nav-menu {
                display: none;
            }
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 5px;
        }
        .status-dot.online {
            background-color: green;
        }
        .status-dot.offline {
            background-color: red;
        }

        .movement-overlay {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 1000;
        }

        .compass-emoji {
            position: fixed;
            font-size: 48px;
            z-index: 2000;
            cursor: move;
            background: none;
            border: none;
            box-shadow: none;
        }

        .pinned {
            position: relative;
        }

        .pin-dot {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: white;
            top: -10px;
            right: -10px;
            z-index: 3000;
        }

        .arc-circle {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid white;
            animation: arc-fade-out 5s ease-out forwards;
            pointer-events: none;
            z-index: 3000;
        }

        @keyframes arc-fade-out {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        .sparkle {
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: white;
            border-radius: 50%;
            animation: sparkle-animation 1s ease-out;
            pointer-events: none;
            z-index: 3000;
        }

        @keyframes sparkle-animation {
            from { transform: scale(0); opacity: 1; }
            to { transform: scale(1); opacity: 0; }
        }

        .click-ring {
            position: absolute;
            width: 150px;
            height: 150px;
            border-radius: 50%;
            border: 3px solid white;
            animation: ring-animation 1s ease-out;
            pointer-events: none;
            z-index: 3000;
        }

        @keyframes ring-animation {
            from { transform: scale(0); opacity: 1; }
            to { transform: scale(1.5); opacity: 0; }
        }

        /* Mobile-specific styles */
        @media (max-width: 768px) {
            body {
                -webkit-user-select: none;  /* Safari */
                -ms-user-select: none;      /* IE 10 and IE 11 */
                user-select: none;          /* Standard syntax */
                touch-action: manipulation;  /* Enable smooth touch interactions */
            }
            
            .debug-ui {
                display: none !important;  /* Hide debug UI on mobile */
            }

            .emoji-draggable {
                touch-action: none;  /* Enable direct manipulation of emojis */
                cursor: move;
            }
        }
    </style>
</head>
<body>
    <canvas id="shader-canvas"></canvas>
    <canvas id="particle-canvas"></canvas>
    <div class="content-overlay">
        <div id="logo" class="psi-header">Œ®</div>
        <div class="title" id="dynamic-title">WORLDTREE</div>
        <div class="server-data">
            <span>node: psi-wtmn-01</span>‚Ä¢
            <span>uptime: 127.4h</span>‚Ä¢
            <span>peers: 47</span>‚Ä¢
            <span>latency: 23ms</span>‚Ä¢
            <span>throughput: 1.2GB/s</span>‚Ä¢
            <span>load: 0.42</span>‚Ä¢
            <span>memory: 84.2%</span>‚Ä¢
            <span>temp: 42.3¬∞C</span>
        </div>
        <div id="poetry">Beyond œâ, a trembling bridge; beyond that, echoes of greater infinities.</div>
        <div id="context">An infinite expanse folds upon itself, spiraling into recursive echoes of boundless order. Each step forward unveils new depths, where the horizon collapses into a shimmering lattice of structure and dissolution.</div>
        <div id="status-container">
            <div id="status-dot" class="status-dot offline"></div>
            <span id="online-count">0 users online</span>
        </div>
    </div>

    <div id="navigation-container"></div>
    <div id="compass-emoji" class="compass-emoji">üß≠</div>

    <div id="movement-overlay" class="movement-overlay">Movement: 0</div>
    <div id="average-motion-overlay" class="movement-overlay" style="bottom: 60px;">Average Motion: 0</div>

    <script id="vertexShader" type="x-shader/x-vertex">
        void main() {
            gl_Position = vec4(position, 1.0);
        }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
        uniform float time;
        uniform vec2 resolution;

        float random(vec2 st) {
            return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
        }

        float noise(vec2 st) {
            vec2 i = floor(st);
            vec2 f = fract(st);
            
            float a = random(i);
            float b = random(i + vec2(1.0, 0.0));
            float c = random(i + vec2(0.0, 1.0));
            float d = random(i + vec2(1.0, 1.0));

            vec2 u = f * f * (3.0 - 2.0 * f);

            return mix(a, b, u.x) +
                    (c - a)* u.y * (1.0 - u.x) +
                    (d - b) * u.x * u.y;
        }

        float fbm(vec2 st) {
            float value = 0.0;
            float amplitude = 0.7;  
            float frequency = 0.0;
            
            for (int i = 0; i < 6; i++) {
                value += amplitude * noise(st);
                st *= 2.2;  
                amplitude *= 0.4;  
            }
            return value;
        }

        void main() {
            vec2 st = gl_FragCoord.xy/resolution.xy;
            st.x *= resolution.x/resolution.y;
            
            vec2 q = vec2(0.);
            q.x = fbm(st + 0.3 * time);  
            q.y = fbm(st + vec2(1.0));
            
            vec2 r = vec2(0.);
            r.x = fbm(st + 1.5 * q + vec2(1.7, 9.2) + 0.25 * time);  
            r.y = fbm(st + 1.5 * q + vec2(8.3, 2.8) + 0.35 * time);  

            float f = fbm(st + r);
            
            vec3 baseColor = vec3(0.05, 0.052, 0.074);  
            vec3 accentColor = vec3(0.478431, 0.635294, 0.968627) * 1.2;  

            vec3 color = mix(
                baseColor,
                accentColor,
                pow(f * f * 1.5, 2.0) * 5.0  
            );

            color = mix(
                color,
                baseColor * 0.5,  
                pow(length(q), 1.5)  
            );

            color = mix(
                color,
                vec3(0.7, 0.75, 0.9),  
                pow(length(r.x), 4.0) * 0.3  
            );

            color = pow(color, vec3(1.2));  

            gl_FragColor = vec4(color, 1.0);
        }
    </script>

    <script type="module">
        import { renderNavigation } from './navigation.js';
        renderNavigation('navigation-container');

        const psiFonts = [
            // Serif fonts
            'Garamond',
            'Baskerville',
            'Times New Roman',
            'Georgia',
            'Bodoni MT',
            'Palatino',
            'Didot',
            'Cambria',
            'Book Antiqua',
            'Goudy Old Style',
            // Sans-serif fonts
            'Helvetica Neue',
            'Arial',
            'Futura',
            'Avant Garde',
            'Century Gothic',
            'Optima',
            'Franklin Gothic',
            'Univers',
            'Frutiger',
            'Gill Sans'
        ];

        let currentPsiFont = 0;
        const psiHeader = document.querySelector('.psi-header');
        
        function cyclePsiFont() {
            currentPsiFont = (currentPsiFont + 1) % psiFonts.length;
            psiHeader.style.fontFamily = psiFonts[currentPsiFont];
            psiHeader.style.transition = 'font-family 0.3s ease, transform 0.3s ease';
            psiHeader.style.transform = 'scale(1.2)';
            setTimeout(() => {
                psiHeader.style.transform = 'scale(1)';
            }, 300);
        }

        function createIntenseParticleEffect(x, y) {
            console.log('Intense particle effect triggered at:', x, y);
            const particles = [];
            for (let i = 0; i < 200; i++) { // Increased particle count for intensity
                const particle = new Particle(x, y, Math.random() * 2 + 1); // Smaller points
                particle.vx = (Math.random() - 0.5) * 6 + Math.sin(i) * 0.5; // Added turbulence
                particle.vy = (Math.random() - 0.5) * 6 + Math.cos(i) * 0.5; // Added turbulence
                particles.push(particle);
            }

            const particleCanvas = document.getElementById('particle-canvas');
            const ctx = particleCanvas.getContext('2d');

            function animateParticles() {
                ctx.clearRect(0, 0, particleCanvas.width, particleCanvas.height);
                particles.forEach((p, index) => {
                    p.update();
                    p.draw();
                    if (p.size <= 0.5) {
                        particles.splice(index, 1);
                    }
                });
                if (particles.length > 0) {
                    requestAnimationFrame(animateParticles);
                }
            }
            animateParticles();
        }

        psiHeader.addEventListener('dblclick', (e) => {
            createIntenseParticleEffect(e.clientX, e.clientY);
        });

        let psiClickCount = 0;
        let psiClickTimeout;

        document.getElementById('logo').addEventListener('click', (e) => {
            psiClickCount++;

            createClickRing(e.clientX, e.clientY);

            if (psiClickCount === 1) {
                psiClickTimeout = setTimeout(() => {
                    psiClickCount = 0;
                }, 2000);
            }

            if (psiClickCount === 5) {
                clearTimeout(psiClickTimeout);
                psiClickCount = 0;

                const xOffset = Math.random() * 100 - 50;
                const yOffset = Math.random() * 100 - 50;
                createAppleEmoji(e.clientX + xOffset, e.clientY + yOffset);
            }

            e.stopPropagation(); // Prevent particle system click
            cyclePsiFont();
            collapseParticles(collapseLevel); // Still trigger particles
        });

        // Initialize with random font
        currentPsiFont = Math.floor(Math.random() * psiFonts.length);
        psiHeader.style.fontFamily = psiFonts[currentPsiFont];

        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js';

        const shaderCanvas = document.getElementById('shader-canvas');
        const renderer = new THREE.WebGLRenderer({ canvas: shaderCanvas });
        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

        const geometry = new THREE.PlaneGeometry(2, 2);
        const material = new THREE.ShaderMaterial({
            vertexShader: document.getElementById('vertexShader').textContent,
            fragmentShader: document.getElementById('fragmentShader').textContent,
            uniforms: {
                time: { value: 0 },
                resolution: { value: new THREE.Vector2() }
            }
        });

        const mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);

        function resizeShaderCanvas() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            renderer.setSize(width, height);
            material.uniforms.resolution.value.set(width, height);
        }

        window.addEventListener('resize', resizeShaderCanvas);
        resizeShaderCanvas();

        function animateShader() {
            requestAnimationFrame(animateShader);
            material.uniforms.time.value += 0.003;  
            renderer.render(scene, camera);
        }
        animateShader();

        const canvas = document.getElementById('particle-canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        let particles = [];
        class Particle {
            constructor(x, y, size) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 1.5;
                this.vy = (Math.random() - 0.5) * 1.5;
                this.size = size;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.size *= 0.98;
                if (this.size < 0.5) {
                    this.size = 0;
                }
            }
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 2, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${this.size / 20})`;
                ctx.fill();
            }
        }

        function collapseParticles(iterations) {
            for (let i = 0; i < iterations * 100; i++) {
                let x = canvas.width / 2 + (Math.random() - 0.5) * 200;
                let y = canvas.height / 2 + (Math.random() - 0.5) * 200;
                let size = Math.random() * 20 + 10;
                particles.push(new Particle(x, y, size));
            }
        }

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            particles.forEach((p, index) => {
                p.update();
                p.draw();
                if (p.size <= 0.5) {
                    particles.splice(index, 1);
                }
            });
            requestAnimationFrame(animate);
        }

        let collapseLevel = 1;
        function collapse() {
            collapseLevel += 1;
            collapseParticles(collapseLevel);
            document.getElementById('poetry').innerText = generatePoetry(collapseLevel);
            document.getElementById('context').innerText = generateContext(collapseLevel);
        }

        function generatePoetry(level) {
            const phrases = [
                "Beyond œâ, a trembling bridge...",
                "The next vast silence folds inward...",
                "From the heights of Œµ‚ÇÄ, echoes descend...",
                "A shimmer in the hierarchy, a breath between infinities...",
                "Collapse and rise, an endless recursion..."
            ];
            return phrases[level % phrases.length];
        }

        function generateContext(level) {
            const descriptions = [
                "An infinite expanse folds upon itself, spiraling into recursive echoes of boundless order.",
                "Each step forward unveils new depths, where the horizon collapses into a shimmering lattice of structure and dissolution.",
                "Infinity contracts, revealing a hidden scaffold‚Äîan unseen architecture beneath perception.",
                "A cascade of realities intertwines, where the finite and the boundless dance in ceaseless motion.",
                "Folding upon folding, the grand hierarchy extends beyond sight, collapsing and emerging anew."
            ];
            return descriptions[level % descriptions.length];
        }

        collapseParticles(collapseLevel);
        animate();
        canvas.addEventListener('click', collapse);

        // Dynamic font animation for title
        const fonts = [
            'Arial Black',
            'Helvetica Neue',
            'Futura',
            'Century Gothic',
            'Optima',
            'Didot',
            'Avenir Next',
            'Montserrat',
            'Raleway',
            'Roboto'
        ];

        const title = document.getElementById('dynamic-title');
        const text = title.textContent;
        title.textContent = '';
        
        // Create spans for each letter
        for (let i = 0; i < text.length; i++) {
            const span = document.createElement('span');
            span.textContent = text[i];
            title.appendChild(span);
        }

        // Animate fonts
        function animateFonts() {
            const spans = title.getElementsByTagName('span');
            for (let i = 0; i < spans.length; i++) {
                const span = spans[i];
                if (Math.random() < 0.03) { // 3% chance to change font each frame
                    const randomFont = fonts[Math.floor(Math.random() * fonts.length)];
                    span.style.fontFamily = randomFont;
                }
            }
            requestAnimationFrame(animateFonts);
        }

        animateFonts();

        // Update server data periodically
        function updateServerData() {
            const spans = document.querySelectorAll('.server-data span');
            spans.forEach(span => {
                if (span.textContent.includes('latency')) {
                    span.textContent = `latency: ${Math.floor(15 + Math.random() * 20)}ms`;
                } else if (span.textContent.includes('throughput')) {
                    span.textContent = `throughput: ${(0.8 + Math.random() * 0.8).toFixed(1)}GB/s`;
                } else if (span.textContent.includes('load')) {
                    span.textContent = `load: ${(0.2 + Math.random() * 0.4).toFixed(2)}`;
                } else if (span.textContent.includes('memory')) {
                    span.textContent = `memory: ${(75 + Math.random() * 20).toFixed(1)}%`;
                } else if (span.textContent.includes('temp')) {
                    span.textContent = `temp: ${(40 + Math.random() * 5).toFixed(1)}¬∞C`;
                }
            });
            setTimeout(updateServerData, 2000);
        }

        updateServerData();

        // Navigation menu toggle
        const navToggle = document.querySelector('.nav-toggle');
        const navMenu = document.querySelector('.nav-menu');
        
        navToggle.addEventListener('click', () => {
            navMenu.classList.toggle('active');
            navToggle.style.opacity = navMenu.classList.contains('active') ? '0' : '1';
        });

        // Close menu when clicking outside
        document.addEventListener('click', (e) => {
            if (!navMenu.contains(e.target) && !navToggle.contains(e.target)) {
                navMenu.classList.remove('active');
                navToggle.style.opacity = '1';
            }
        });

        const particles2 = [];
        const particleCount = 10; // Only a handful

        class Particle2 {
            constructor(x, y, speedX, speedY, size) {
                this.x = x;
                this.y = y;
                this.speedX = speedX;
                this.speedY = speedY;
                this.size = size;
            }

            update() {
                this.x += this.speedX;
                this.y += this.speedY;

                // Wrap around the screen
                if (this.x > canvas.width) this.x = 0;
                if (this.y > canvas.height) this.y = 0;
                if (this.x < 0) this.x = canvas.width;
                if (this.y < 0) this.y = canvas.height;
            }

            draw(ctx) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function initParticles2() {
            for (let i = 0; i < particleCount; i++) {
                particles2.push(new Particle2(
                    Math.random() * canvas.width,
                    Math.random() * canvas.height,
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.5,
                    Math.random() * 2 + 1
                ));
            }
        }

        function animateParticles2() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            particles2.forEach(particle => {
                particle.update();
                particle.draw(ctx);
            });
            requestAnimationFrame(animateParticles2);
        }

        initParticles2();
        animateParticles2();

        let ws;
        const statusDot = document.getElementById('status-dot');
        const onlineCount = document.getElementById('online-count');

        function initWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const host = window.location.hostname;
            const port = window.location.port || (protocol === 'wss:' ? '443' : '80');
            const wsUrl = `${protocol}//${host}:${port}`;
            
            ws = new WebSocket(wsUrl);

            ws.onopen = function() {
                console.log('Connected to WebSocket server');
                statusDot.className = 'status-dot online';
            };

            ws.onclose = function() {
                console.log('Disconnected from WebSocket server');
                statusDot.className = 'status-dot offline';
            };

            ws.onmessage = function(event) {
                const data = JSON.parse(event.data);
                if (data.type === 'userupdate') {
                    onlineCount.textContent = `${data.users.length} users online`;
                } else if (data.type === 'serverinfo') {
                    updateServerInfo(data);
                }
            };

            ws.onerror = function(error) {
                console.error('WebSocket error:', error);
            };
        }

        function updateServerInfo(data) {
            if (data.numUsers !== undefined) {
                onlineCount.textContent = `${data.numUsers} users online`;
            }
            // Display additional server info if needed
            console.log('Server Load:', data.load);
            console.log('Memory Usage:', data.memoryUsage);
        }

        document.addEventListener('DOMContentLoaded', initWebSocket);

        function makeDraggable(element) {
            let posX = 0, posY = 0, mouseX = 0, mouseY = 0;

            element.onmousedown = dragMouseDown;

            function dragMouseDown(e) {
                e.preventDefault();
                mouseX = e.clientX;
                mouseY = e.clientY;
                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
            }

            function elementDrag(e) {
                e.preventDefault();
                posX = mouseX - e.clientX;
                posY = mouseY - e.clientY;
                mouseX = e.clientX;
                mouseY = e.clientY;
                element.style.top = (element.offsetTop - posY) + "px";
                element.style.left = (element.offsetLeft - posX) + "px";
            }

            function closeDragElement() {
                document.onmouseup = null;
                document.onmousemove = null;
            }
        }

        makeDraggable(document.querySelector('.nav-menu'));
        const compassEmoji = document.getElementById('compass-emoji');
        makeDraggable(compassEmoji);

        let hideNavTimeout;

        let lastX = 0;
        let lastY = 0;
        let motionHistory = [];
        const historySize = 10;

        let cumulativeMovement = 0;
        let displayedMotion = 0;
        let averageMotion = 0;

        let lastMotion = 0;

        function updateMenuOpacity() {
            // Check if mouse is over the menu
            const isMouseOverMenu1 = navMenu.matches(':hover');
            const isMouseOverCompass = compassEmoji.matches(':hover');

            // Adjust opacity based on average motion and mouse position
            const navOpacity = isMouseOverMenu1 || isMouseOverCompass ? 1 : Math.min(1, Math.max(0, displayedMotion / 30));
            navMenu.style.opacity = navOpacity;
            compassEmoji.style.opacity = navOpacity;

            requestAnimationFrame(updateMenuOpacity);
        }

        updateMenuOpacity();

        function updateMotion() {
            // Calculate delta from last motion
            const deltaMotion = cumulativeMovement - lastMotion;
            lastMotion = cumulativeMovement;

            // Lerp towards the delta motion
            displayedMotion += (deltaMotion - displayedMotion) * 0.1;

            // Update overlays
            document.getElementById('movement-overlay').textContent = `Movement: ${cumulativeMovement.toFixed(2)}`;
            document.getElementById('average-motion-overlay').textContent = `Average Motion: ${displayedMotion.toFixed(2)}`;

            // Check if mouse is over the menu
            const isMouseOverMenu = navMenu.matches(':hover');

            // Adjust nav-menu opacity based on average motion and mouse position
            const navOpacity = isMouseOverMenu ? 1 : Math.min(1, Math.max(0, displayedMotion / 30));
            navMenu.style.opacity = navOpacity;

            requestAnimationFrame(updateMotion);
        }

        updateMotion();

        setInterval(() => {
            // Store the current cumulative movement for delta calculation
            lastMotion = cumulativeMovement;
        }, 100);

        setInterval(() => {
            // Calculate average motion over the last second
            averageMotion = motionHistory.reduce((a, b) => a + b, 0) / motionHistory.length;
            motionHistory = [];
        }, 1000);

        document.addEventListener('mousemove', (e) => {
            clearTimeout(hideNavTimeout);
            navMenu.classList.remove('hidden');

            const deltaX = e.clientX - lastX;
            const deltaY = e.clientY - lastY;
            const motion = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

            // Update motion history
            motionHistory.push(motion);

            // Update cumulative movement
            cumulativeMovement += motion;

            lastX = e.clientX;
            lastY = e.clientY;

            hideNavTimeout = setTimeout(() => {
                navMenu.classList.add('hidden');
            }, 1000);
        });

        let isPinned = false;
        let pinElement = null;
        let arcElement = null;

        compassEmoji.addEventListener('mousedown', (e) => {
            e.preventDefault();
            const holdDuration = 500; // Duration to hold for pinning
            let holdTimeout;

            function startHold() {
                holdTimeout = setTimeout(() => {
                    isPinned = !isPinned;
                    compassEmoji.classList.toggle('pinned', isPinned);

                    if (isPinned) {
                        pinElement = document.createElement('div');
                        pinElement.className = 'pin-dot';
                        compassEmoji.appendChild(pinElement);
                    } else if (pinElement) {
                        pinElement.remove();
                        pinElement = null;
                    }
                }, holdDuration);

                arcElement = document.createElement('div');
                arcElement.className = 'arc-circle';
                arcElement.style.left = `${e.clientX - 20}px`;
                arcElement.style.top = `${e.clientY - 20}px`;
                document.body.appendChild(arcElement);
                setTimeout(() => arcElement.remove(), 5000);
            }

            function clearHold() {
                clearTimeout(holdTimeout);
            }

            compassEmoji.addEventListener('mouseup', clearHold);
            compassEmoji.addEventListener('mouseleave', clearHold);

            startHold();
        });

        function createClickRing(x, y) {
            console.log('Click ring effect triggered at:', x, y);
            const clickRing = document.createElement('div');
            clickRing.className = 'click-ring';
            clickRing.style.left = `${x - 75}px`;
            clickRing.style.top = `${y - 75}px`;
            document.body.appendChild(clickRing);
            setTimeout(() => clickRing.remove(), 1000);
        }

        document.addEventListener('click', (e) => {
            createClickRing(e.clientX, e.clientY);
        });

        document.getElementById('logo').addEventListener('click', (e) => {
            psiClickCount++;

            createClickRing(e.clientX, e.clientY);

            if (psiClickCount === 1) {
                psiClickTimeout = setTimeout(() => {
                    psiClickCount = 0;
                }, 2000);
            }

            if (psiClickCount === 5) {
                clearTimeout(psiClickTimeout);
                psiClickCount = 0;

                const xOffset = Math.random() * 100 - 50;
                const yOffset = Math.random() * 100 - 50;
                createAppleEmoji(e.clientX + xOffset, e.clientY + yOffset);
            }

            e.stopPropagation(); // Prevent particle system click
            cyclePsiFont();
            collapseParticles(collapseLevel); // Still trigger particles
        });

        function createButterflyEmoji(x, y) {
            console.log('Butterfly emoji created at:', x, y);
            const butterflyEmoji = document.createElement('div');
            butterflyEmoji.textContent = 'ü¶ã';
            butterflyEmoji.style.position = 'absolute';
            const size = Math.random() * 20 + 30; // Random size between 30px and 50px
            butterflyEmoji.style.fontSize = `${size}px`;
            const colors = ['#FF69B4', '#FFD700', '#ADFF2F', '#00BFFF', '#FF4500'];
            const randomColor = colors[Math.floor(Math.random() * colors.length)];
            butterflyEmoji.style.color = randomColor;
            butterflyEmoji.style.left = `${x}px`;
            butterflyEmoji.style.top = `${y}px`;
            butterflyEmoji.style.zIndex = 2000;
            butterflyEmoji.style.userSelect = 'none';
            document.body.appendChild(butterflyEmoji);
            makeDraggable(butterflyEmoji);

            setTimeout(() => {
                butterflyEmoji.remove();
            }, 30000); // Butterfly lives for 30 seconds
        }

        function createWormEmoji(x, y) {
            console.log('Worm emoji created at:', x, y);
            const wormEmoji = document.createElement('div');
            wormEmoji.textContent = 'üêõ';
            wormEmoji.style.position = 'absolute';
            wormEmoji.style.fontSize = '30px';
            wormEmoji.style.left = `${x}px`;
            wormEmoji.style.top = `${y}px`;
            wormEmoji.style.zIndex = 2000;
            wormEmoji.style.userSelect = 'none';
            wormEmoji.className = 'emoji-draggable';
            document.body.appendChild(wormEmoji);

            let tapCount = 0;
            wormEmoji.addEventListener('click', (e) => {
                tapCount++;
                if (tapCount === 15) {
                    const wormX = e.clientX;
                    const wormY = e.clientY;
                    createButterflyEmoji(wormX, wormY);
                    wormEmoji.remove();
                }
            });

            function handleTouchEvents(element) {
                let touchStartX = 0;
                let touchStartY = 0;
                
                element.addEventListener('touchstart', (e) => {
                    const touch = e.touches[0];
                    touchStartX = touch.clientX - parseFloat(element.style.left || 0);
                    touchStartY = touch.clientY - parseFloat(element.style.top || 0);
                    e.preventDefault(); // Prevent scrolling while dragging
                });

                element.addEventListener('touchmove', (e) => {
                    const touch = e.touches[0];
                    element.style.left = `${touch.clientX - touchStartX}px`;
                    element.style.top = `${touch.clientY - touchStartY}px`;
                    e.preventDefault();
                });
            }

            handleTouchEvents(wormEmoji);

            setTimeout(() => {
                wormEmoji.remove();
            }, 10000); // Worm lives for 10 seconds
        }

        function createAppleEmoji(x, y) {
            console.log('Apple emoji created at:', x, y);
            const appleEmoji = document.createElement('div');
            appleEmoji.textContent = 'üçé';
            appleEmoji.style.position = 'absolute';
            const size = Math.random() * 20 + 40; // Random size between 40px and 60px
            appleEmoji.style.fontSize = `${size}px`;
            appleEmoji.style.left = `${x}px`;
            appleEmoji.style.top = `${y}px`;
            appleEmoji.style.zIndex = 2000;
            appleEmoji.style.userSelect = 'none';
            appleEmoji.className = 'emoji-draggable';
            document.body.appendChild(appleEmoji);

            function handleTouchEvents(element) {
                let touchStartX = 0;
                let touchStartY = 0;
                
                element.addEventListener('touchstart', (e) => {
                    const touch = e.touches[0];
                    touchStartX = touch.clientX - parseFloat(element.style.left || 0);
                    touchStartY = touch.clientY - parseFloat(element.style.top || 0);
                    e.preventDefault(); // Prevent scrolling while dragging
                });

                element.addEventListener('touchmove', (e) => {
                    const touch = e.touches[0];
                    element.style.left = `${touch.clientX - touchStartX}px`;
                    element.style.top = `${touch.clientY - touchStartY}px`;
                    e.preventDefault();
                });
            }

            handleTouchEvents(appleEmoji);

            appleEmoji.addEventListener('dblclick', (e) => {
                if (Math.random() < 0.5) { // 50% chance to create a worm
                    createWormEmoji(e.clientX, e.clientY);
                }
            });

            const lifespan = Math.random() * 5000 + 5000; // Random lifespan between 5 and 10 seconds
            const desaturationInterval = lifespan / 100;
            let saturation = 1;

            const desaturate = setInterval(() => {
                saturation -= 0.01;
                appleEmoji.style.filter = `saturate(${saturation})`;
                if (saturation <= 0) {
                    clearInterval(desaturate);
                }
            }, desaturationInterval);

            setTimeout(() => {
                const currentX = parseFloat(appleEmoji.style.left);
                const currentY = parseFloat(appleEmoji.style.top);
                appleEmoji.remove();
                clearInterval(desaturate);
                emitParticles(currentX, currentY);
            }, lifespan);
        }

        compassEmoji.addEventListener('dblclick', (e) => {
            createClickRing(e.clientX, e.clientY);
        });

        function emitParticles(x, y) {
            for (let i = 0; i < 10; i++) {
                const particle = document.createElement('div');
                particle.className = 'sparkle';
                particle.style.left = `${x + Math.random() * 20 - 10}px`;
                particle.style.top = `${y + Math.random() * 20 - 10}px`;
                document.body.appendChild(particle);
                setTimeout(() => particle.remove(), 1000);
            }
        }

        // Randomize compass position on page load
        const randomX = Math.random() * (window.innerWidth - 48);
        const randomY = Math.random() * (window.innerHeight - 48);
        compassEmoji.style.left = `${randomX}px`;
        compassEmoji.style.top = `${randomY}px`;
    </script>
</body>
</html>
