<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HyperGrid 8 - Quantum Hyperspace</title>
    <!-- Add gl-matrix library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; color: #fff; font-family: Arial, sans-serif; }
        canvas { display: block; }
        
        #controls {
            position: fixed;
            top: 10px;
            right: 10px;
            width: 300px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .control-group {
            margin: 10px 0;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
            color: #aaa;
        }
        
        input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }
        
        .value-display {
            float: right;
            color: #888;
            font-size: 0.8em;
        }
        
        #quantum-navigator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 200px;
            background: radial-gradient(circle at 50% 50%, 
                rgba(255, 255, 255, 0.1),
                rgba(0, 100, 255, 0.15),
                rgba(0, 0, 0, 0.5)
            );
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.2);
            cursor: crosshair;
            box-shadow: 0 0 40px rgba(0, 100, 255, 0.2);
            z-index: 1000;
            pointer-events: all;
        }

        #navigator-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            pointer-events: none;
        }

        #navigator-vector {
            position: absolute;
            width: 6px;
            height: 6px;
            background: rgba(0, 255, 255, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px cyan;
        }

        #quantum-hud {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 280px;
            background: rgba(0, 20, 40, 0.8);
            border: 1px solid rgba(0, 150, 255, 0.3);
            border-radius: 10px;
            padding: 15px;
            color: #fff;
            font-family: monospace;
            backdrop-filter: blur(5px);
        }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    
    <div id="controls">
        <div class="control-group">
            <label for="grid-density">Grid Density</label>
            <input type="range" id="grid-density" min="2" max="20" value="5">
            <span class="value-display" id="density-value">5</span>
        </div>
        
        <div class="control-group">
            <label for="volume-scale">Volume Scale</label>
            <input type="range" id="volume-scale" min="0.1" max="5" step="0.1" value="1">
            <span class="value-display" id="scale-value">1.0</span>
        </div>
    </div>

    <div id="quantum-navigator">
        <div id="navigator-grid"></div>
        <div id="navigator-vector"></div>
    </div>

    <div id="quantum-hud">
        <div id="quantum-hud-header">
            <span class="hud-title">QUANTUM COORDINATES</span>
            <span id="quantum-time">t=0.000</span>
        </div>
        <div id="quantum-coordinates"></div>
    </div>

    <script>
        (function() {
            // Initialize WebGL
            const canvas = document.getElementById("glCanvas");
            const gl = canvas.getContext("webgl");

            if (!gl) {
                alert("Unable to initialize WebGL. Your browser may not support it.");
                return;
            }

            // Vertex shader program
            const vertexShaderSource = `
                attribute vec4 position;
                attribute vec3 color;
                attribute float pointSize;
                uniform mat4 matrix;
                varying vec3 vColor;
                void main() {
                    gl_Position = matrix * position;
                    gl_PointSize = pointSize;
                    vColor = color;
                }
            `;

            // Fragment shader program
            const fragmentShaderSource = `
                precision mediump float;
                varying vec3 vColor;
                void main() {
                    gl_FragColor = vec4(vColor, 1.0);
                }
            `;

            // Create shader program
            function createShader(gl, type, source) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                return shader;
            }

            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            gl.useProgram(program);

            // Get attribute locations
            const positionLocation = gl.getAttribLocation(program, "position");
            const colorLocation = gl.getAttribLocation(program, "color");
            const sizeLocation = gl.getAttribLocation(program, "pointSize");
            const matrixLocation = gl.getUniformLocation(program, "matrix");

            // Initialize buffers
            const positionBuffer = gl.createBuffer();
            const colorBuffer = gl.createBuffer();
            const sizeBuffer = gl.createBuffer();

            // Generate points
            function generatePoints(size) {
                const points = [];
                const colors = [];
                const sizes = [];
                const step = 2.0 / (size - 1);

                for (let w = 0; w < size; w++) {
                    for (let x = 0; x < size; x++) {
                        for (let y = 0; y < size; y++) {
                            for (let z = 0; z < size; z++) {
                                points.push(
                                    w * step - 1.0,
                                    x * step - 1.0,
                                    y * step - 1.0,
                                    z * step - 1.0
                                );

                                // Generate unique colors based on position
                                colors.push(
                                    0.5 + 0.5 * Math.sin(w * 0.5),
                                    0.5 + 0.5 * Math.cos(x * 0.5),
                                    0.5 + 0.5 * Math.sin((y + z) * 0.25)
                                );

                                // Vary point size based on position
                                sizes.push(2.0 + Math.sin(w * 0.5) * Math.cos(z * 0.5));
                            }
                        }
                    }
                }

                return { points, colors, sizes };
            }

            // Update points
            function updatePoints(size) {
                const { points, colors, sizes } = generatePoints(size);

                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(points), gl.STATIC_DRAW);

                gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);

                gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sizes), gl.STATIC_DRAW);

                return points.length / 4;
            }

            // Initialize rotation state
            let rotationState = {
                wx: 0, wy: 0, wz: 0,
                xy: 0, xz: 0, yz: 0,
                autoRotate: true
            };

            // Get 4D rotation matrix
            function get4DRotationMatrix(wx, wy, wz, xy, xz, yz) {
                const c1 = Math.cos(wx), s1 = Math.sin(wx);
                const c2 = Math.cos(wy), s2 = Math.sin(wy);
                const c3 = Math.cos(wz), s3 = Math.sin(wz);
                const c4 = Math.cos(xy), s4 = Math.sin(xy);
                const c5 = Math.cos(xz), s5 = Math.sin(xz);
                const c6 = Math.cos(yz), s6 = Math.sin(yz);

                const matrix = mat4.create();

                // Combine all rotations
                matrix[0] = c1*c2;
                matrix[1] = c1*s2*s3 - s1*c3;
                matrix[2] = c1*s2*c3 + s1*s3;
                matrix[3] = 0;

                matrix[4] = s1*c2;
                matrix[5] = s1*s2*s3 + c1*c3;
                matrix[6] = s1*s2*c3 - c1*s3;
                matrix[7] = 0;

                matrix[8] = -s2;
                matrix[9] = c2*s3;
                matrix[10] = c2*c3;
                matrix[11] = 0;

                matrix[12] = 0;
                matrix[13] = 0;
                matrix[14] = 0;
                matrix[15] = 1;

                return matrix;
            }

            // Update rotation state
            function updateRotations(currentTime) {
                if (rotationState.autoRotate) {
                    const t = currentTime * 0.001;
                    rotationState.wx = Math.sin(t * 0.3) * 0.5;
                    rotationState.wy = Math.cos(t * 0.4) * 0.5;
                    rotationState.wz = Math.sin(t * 0.5) * 0.5;
                    rotationState.xy = Math.cos(t * 0.6) * 0.5;
                    rotationState.xz = Math.sin(t * 0.7) * 0.5;
                    rotationState.yz = Math.cos(t * 0.8) * 0.5;
                }
            }

            // Initialize quantum navigator
            function initQuantumNavigator() {
                const navigator = document.getElementById('quantum-navigator');
                const vector = document.getElementById('navigator-vector');
                
                let isDragging = false;
                let startX, startY;

                navigator.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    const rect = navigator.getBoundingClientRect();
                    startX = e.clientX - rect.left;
                    startY = e.clientY - rect.top;
                    updateRotationVector(startX, startY);
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    const rect = navigator.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    updateRotationVector(x, y);
                });

                document.addEventListener('mouseup', () => {
                    isDragging = false;
                });
            }

            // Update rotation vector
            function updateRotationVector(x, y) {
                const navigator = document.getElementById('quantum-navigator');
                const vector = document.getElementById('navigator-vector');
                const rect = navigator.getBoundingClientRect();
                
                const centerX = rect.width / 2;
                const centerY = rect.height / 2;
                
                const dx = x - centerX;
                const dy = y - centerY;
                
                const radius = Math.min(rect.width, rect.height) / 2;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx);
                
                const normalizedDistance = Math.min(distance / radius, 1);
                
                vector.style.left = `${x}px`;
                vector.style.top = `${y}px`;
                
                // Update rotation state based on vector position
                rotationState.autoRotate = false;
                rotationState.wx = normalizedDistance * Math.cos(angle);
                rotationState.wy = normalizedDistance * Math.sin(angle);
            }

            // Initialize quantum HUD
            function initQuantumHud() {
                const hud = document.getElementById('quantum-hud');
                const coordinates = document.getElementById('quantum-coordinates');
                const time = document.getElementById('quantum-time');
            }

            // Update quantum HUD
            function updateQuantumHud(currentTime) {
                const coordinates = document.getElementById('quantum-coordinates');
                const time = document.getElementById('quantum-time');
                
                // Update time display
                time.textContent = `t=${(currentTime * 0.001).toFixed(3)}`;
                
                // Update coordinates display
                const coordsText = `
                    W: ${rotationState.wx.toFixed(3)}
                    X: ${rotationState.wy.toFixed(3)}
                    Y: ${rotationState.wz.toFixed(3)}
                    Z: ${rotationState.xy.toFixed(3)}
                `;
                coordinates.textContent = coordsText;
            }

            // Render loop
            function render(currentTime) {
                // Update canvas size
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);

                // Clear canvas
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                // Update rotations
                updateRotations(currentTime);

                // Get rotation matrix
                const matrix = get4DRotationMatrix(
                    rotationState.wx, rotationState.wy, rotationState.wz,
                    rotationState.xy, rotationState.xz, rotationState.yz
                );

                // Set uniforms
                gl.uniformMatrix4fv(matrixLocation, false, matrix);

                // Enable attributes
                gl.enableVertexAttribArray(positionLocation);
                gl.enableVertexAttribArray(colorLocation);
                gl.enableVertexAttribArray(sizeLocation);

                // Bind buffers and set attributes
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.vertexAttribPointer(positionLocation, 4, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
                gl.vertexAttribPointer(colorLocation, 3, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer);
                gl.vertexAttribPointer(sizeLocation, 1, gl.FLOAT, false, 0, 0);

                // Draw points
                gl.drawArrays(gl.POINTS, 0, numPoints);

                // Update quantum HUD
                updateQuantumHud(currentTime);

                // Request next frame
                requestAnimationFrame(render);
            }

            // Initialize
            let numPoints = updatePoints(5);
            initQuantumNavigator();
            initQuantumHud();

            // Add event listeners
            const gridDensityControl = document.getElementById('grid-density');
            const densityValue = document.getElementById('density-value');
            
            gridDensityControl.addEventListener('input', () => {
                const size = parseInt(gridDensityControl.value);
                densityValue.textContent = size;
                numPoints = updatePoints(size);
            });

            const volumeScaleControl = document.getElementById('volume-scale');
            const scaleValue = document.getElementById('scale-value');
            
            volumeScaleControl.addEventListener('input', () => {
                const scale = parseFloat(volumeScaleControl.value);
                scaleValue.textContent = scale.toFixed(1);
            });

            // Start rendering
            requestAnimationFrame(render);
        })();
    </script>
</body>
</html>
