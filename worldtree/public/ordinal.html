<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ψ-WTMN Ordinal</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background-color: #1a1b26;
            color: #a9b1d6;
            overflow: hidden;
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        #shader-canvas {
            z-index: 1;
        }

        #particle-canvas {
            z-index: 2;
        }

        .content-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 3;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            user-select: none;
        }

        .psi-header {
            font-size: 120px;
            font-weight: bold;
            color: #7aa2f7;
            margin: 0 0 10px 0;
            text-shadow: 0 0 20px rgba(122, 162, 247, 0.5);
            animation: glow 2s ease-in-out infinite alternate;
        }

        .title {
            font-size: 24px;
            font-weight: 600;
            color: #a9b1d6;
            margin: 0 0 20px 0;
            letter-spacing: 2px;
        }

        .title span {
            display: inline-block;
            transition: font-family 0.5s ease;
        }

        .server-data {
            font-size: 12px;
            color: rgba(169, 177, 214, 0.6);
            text-align: center;
            font-family: 'Courier New', monospace;
            line-height: 1.4;
            max-width: 600px;
            margin: 0;
        }

        .server-data span {
            margin: 0 8px;
        }

        #poetry {
            font-size: 24px;
            color: rgba(169, 177, 214, 0.8);
            text-align: center;
            margin: 20px 0;
            max-width: 80%;
            text-shadow: 0 0 10px rgba(169, 177, 214, 0.3);
        }

        #context {
            font-size: 18px;
            color: rgba(169, 177, 214, 0.7);
            text-align: center;
            margin: 0;
            max-width: 80%;
            text-shadow: 0 0 10px rgba(169, 177, 214, 0.3);
        }

        @keyframes glow {
            from {
                text-shadow: 0 0 20px rgba(122, 162, 247, 0.5);
            }
            to {
                text-shadow: 0 0 30px rgba(122, 162, 247, 0.8);
            }
        }
    </style>
</head>
<body>
    <canvas id="shader-canvas"></canvas>
    <canvas id="particle-canvas"></canvas>
    <div class="content-overlay">
        <div class="psi-header">Ψ</div>
        <div class="title" id="dynamic-title">WORLDTREE</div>
        <div class="server-data">
            <span>node: psi-wtmn-01</span>•
            <span>uptime: 127.4h</span>•
            <span>peers: 47</span>•
            <span>latency: 23ms</span>•
            <span>throughput: 1.2GB/s</span>•
            <span>load: 0.42</span>•
            <span>memory: 84.2%</span>•
            <span>temp: 42.3°C</span>
        </div>
        <div id="poetry">Beyond ω, a trembling bridge; beyond that, echoes of greater infinities.</div>
        <div id="context">An infinite expanse folds upon itself, spiraling into recursive echoes of boundless order. Each step forward unveils new depths, where the horizon collapses into a shimmering lattice of structure and dissolution.</div>
    </div>

    <script id="vertexShader" type="x-shader/x-vertex">
        void main() {
            gl_Position = vec4(position, 1.0);
        }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
        uniform float time;
        uniform vec2 resolution;

        float random(vec2 st) {
            return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
        }

        float noise(vec2 st) {
            vec2 i = floor(st);
            vec2 f = fract(st);
            
            float a = random(i);
            float b = random(i + vec2(1.0, 0.0));
            float c = random(i + vec2(0.0, 1.0));
            float d = random(i + vec2(1.0, 1.0));

            vec2 u = f * f * (3.0 - 2.0 * f);

            return mix(a, b, u.x) +
                    (c - a)* u.y * (1.0 - u.x) +
                    (d - b) * u.x * u.y;
        }

        float fbm(vec2 st) {
            float value = 0.0;
            float amplitude = 0.7;  
            float frequency = 0.0;
            
            for (int i = 0; i < 6; i++) {
                value += amplitude * noise(st);
                st *= 2.2;  
                amplitude *= 0.4;  
            }
            return value;
        }

        void main() {
            vec2 st = gl_FragCoord.xy/resolution.xy;
            st.x *= resolution.x/resolution.y;
            
            vec2 q = vec2(0.);
            q.x = fbm(st + 0.3 * time);  
            q.y = fbm(st + vec2(1.0));
            
            vec2 r = vec2(0.);
            r.x = fbm(st + 1.5 * q + vec2(1.7, 9.2) + 0.25 * time);  
            r.y = fbm(st + 1.5 * q + vec2(8.3, 2.8) + 0.35 * time);  

            float f = fbm(st + r);
            
            vec3 baseColor = vec3(0.05, 0.052, 0.074);  
            vec3 accentColor = vec3(0.478431, 0.635294, 0.968627) * 1.2;  

            vec3 color = mix(
                baseColor,
                accentColor,
                pow(f * f * 1.5, 2.0) * 5.0  
            );

            color = mix(
                color,
                baseColor * 0.5,  
                pow(length(q), 1.5)  
            );

            color = mix(
                color,
                vec3(0.7, 0.75, 0.9),  
                pow(length(r.x), 4.0) * 0.3  
            );

            color = pow(color, vec3(1.2));  

            gl_FragColor = vec4(color, 1.0);
        }
    </script>

    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js';

        const shaderCanvas = document.getElementById('shader-canvas');
        const renderer = new THREE.WebGLRenderer({ canvas: shaderCanvas });
        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

        const geometry = new THREE.PlaneGeometry(2, 2);
        const material = new THREE.ShaderMaterial({
            vertexShader: document.getElementById('vertexShader').textContent,
            fragmentShader: document.getElementById('fragmentShader').textContent,
            uniforms: {
                time: { value: 0 },
                resolution: { value: new THREE.Vector2() }
            }
        });

        const mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);

        function resizeShaderCanvas() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            renderer.setSize(width, height);
            material.uniforms.resolution.value.set(width, height);
        }

        window.addEventListener('resize', resizeShaderCanvas);
        resizeShaderCanvas();

        function animateShader() {
            requestAnimationFrame(animateShader);
            material.uniforms.time.value += 0.003;  
            renderer.render(scene, camera);
        }
        animateShader();

        const canvas = document.getElementById('particle-canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        let particles = [];
        class Particle {
            constructor(x, y, size) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 1.5;
                this.vy = (Math.random() - 0.5) * 1.5;
                this.size = size;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.size *= 0.98;
                if (this.size < 0.5) {
                    this.size = 0;
                }
            }
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 2, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${this.size / 20})`;
                ctx.fill();
            }
        }

        function collapseParticles(iterations) {
            for (let i = 0; i < iterations * 20; i++) {
                let x = canvas.width / 2 + (Math.random() - 0.5) * 300;
                let y = canvas.height / 2 + (Math.random() - 0.5) * 300;
                let size = Math.random() * 15 + 8;
                particles.push(new Particle(x, y, size));
            }
        }

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            particles.forEach((p, index) => {
                p.update();
                p.draw();
                if (p.size <= 0.5) {
                    particles.splice(index, 1);
                }
            });
            requestAnimationFrame(animate);
        }

        let collapseLevel = 1;
        function collapse() {
            collapseLevel += 1;
            collapseParticles(collapseLevel);
            document.getElementById('poetry').innerText = generatePoetry(collapseLevel);
            document.getElementById('context').innerText = generateContext(collapseLevel);
        }

        function generatePoetry(level) {
            const phrases = [
                "Beyond ω, a trembling bridge...",
                "The next vast silence folds inward...",
                "From the heights of ε₀, echoes descend...",
                "A shimmer in the hierarchy, a breath between infinities...",
                "Collapse and rise, an endless recursion..."
            ];
            return phrases[level % phrases.length];
        }

        function generateContext(level) {
            const descriptions = [
                "An infinite expanse folds upon itself, spiraling into recursive echoes of boundless order.",
                "Each step forward unveils new depths, where the horizon collapses into a shimmering lattice of structure and dissolution.",
                "Infinity contracts, revealing a hidden scaffold—an unseen architecture beneath perception.",
                "A cascade of realities intertwines, where the finite and the boundless dance in ceaseless motion.",
                "Folding upon folding, the grand hierarchy extends beyond sight, collapsing and emerging anew."
            ];
            return descriptions[level % descriptions.length];
        }

        collapseParticles(collapseLevel);
        animate();
        canvas.addEventListener('click', collapse);

        // Dynamic font animation for title
        const fonts = [
            'Arial Black',
            'Helvetica Neue',
            'Futura',
            'Century Gothic',
            'Optima',
            'Didot',
            'Avenir Next',
            'Montserrat',
            'Raleway',
            'Roboto'
        ];

        const title = document.getElementById('dynamic-title');
        const text = title.textContent;
        title.textContent = '';
        
        // Create spans for each letter
        for (let i = 0; i < text.length; i++) {
            const span = document.createElement('span');
            span.textContent = text[i];
            title.appendChild(span);
        }

        // Animate fonts
        function animateFonts() {
            const spans = title.getElementsByTagName('span');
            for (let i = 0; i < spans.length; i++) {
                const span = spans[i];
                if (Math.random() < 0.03) { // 3% chance to change font each frame
                    const randomFont = fonts[Math.floor(Math.random() * fonts.length)];
                    span.style.fontFamily = randomFont;
                }
            }
            requestAnimationFrame(animateFonts);
        }

        animateFonts();

        // Update server data periodically
        function updateServerData() {
            const spans = document.querySelectorAll('.server-data span');
            spans.forEach(span => {
                if (span.textContent.includes('latency')) {
                    span.textContent = `latency: ${Math.floor(15 + Math.random() * 20)}ms`;
                } else if (span.textContent.includes('throughput')) {
                    span.textContent = `throughput: ${(0.8 + Math.random() * 0.8).toFixed(1)}GB/s`;
                } else if (span.textContent.includes('load')) {
                    span.textContent = `load: ${(0.2 + Math.random() * 0.4).toFixed(2)}`;
                } else if (span.textContent.includes('memory')) {
                    span.textContent = `memory: ${(75 + Math.random() * 20).toFixed(1)}%`;
                } else if (span.textContent.includes('temp')) {
                    span.textContent = `temp: ${(40 + Math.random() * 5).toFixed(1)}°C`;
                }
            });
            setTimeout(updateServerData, 2000);
        }

        updateServerData();
    </script>
</body>
</html>
